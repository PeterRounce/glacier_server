{
  "version": 3,
  "sources": ["../../bitcoinjs-lib/src/networks.js", "../../bitcoinjs-lib/src/bip66.js", "../../bitcoinjs-lib/src/ops.js", "../../bitcoinjs-lib/src/push_data.js", "../../bitcoinjs-lib/src/script_number.js", "../../bitcoinjs-lib/src/types.js", "../../bitcoinjs-lib/src/script_signature.js", "../../bitcoinjs-lib/src/script.js", "../../bitcoinjs-lib/src/payments/lazy.js", "../../bitcoinjs-lib/src/payments/embed.js", "../../bitcoinjs-lib/src/payments/p2ms.js", "../../bitcoinjs-lib/src/payments/p2pk.js", "../../@noble/hashes/src/sha1.ts", "../../bitcoinjs-lib/src/crypto.js", "../../base-x/src/index.js", "../../bs58/index.js", "../../bs58check/base.js", "../../bs58check/index.js", "../../bitcoinjs-lib/src/payments/p2pkh.js", "../../bitcoinjs-lib/src/payments/p2sh.js", "../../bech32/dist/index.js", "../../bitcoinjs-lib/src/payments/p2wpkh.js", "../../bitcoinjs-lib/src/payments/p2wsh.js", "../../bitcoinjs-lib/src/ecc_lib.js", "../../varuint-bitcoin/index.js", "../../bitcoinjs-lib/src/bufferutils.js", "../../bitcoinjs-lib/src/payments/bip341.js", "../../bitcoinjs-lib/src/payments/p2tr.js", "../../bitcoinjs-lib/src/payments/index.js", "../../bitcoinjs-lib/src/address.js", "../../bitcoinjs-lib/src/merkle.js", "../../bitcoinjs-lib/src/transaction.js", "../../bitcoinjs-lib/src/block.js", "../../bip174/src/lib/typeFields.js", "../../bip174/src/lib/converter/global/globalXpub.js", "../../bip174/src/lib/converter/global/unsignedTx.js", "../../bip174/src/lib/converter/input/finalScriptSig.js", "../../bip174/src/lib/converter/input/finalScriptWitness.js", "../../bip174/src/lib/converter/input/nonWitnessUtxo.js", "../../bip174/src/lib/converter/input/partialSig.js", "../../bip174/src/lib/converter/input/porCommitment.js", "../../bip174/src/lib/converter/input/sighashType.js", "../../bip174/src/lib/converter/input/tapKeySig.js", "../../bip174/src/lib/converter/input/tapLeafScript.js", "../../bip174/src/lib/converter/input/tapMerkleRoot.js", "../../bip174/src/lib/converter/input/tapScriptSig.js", "../../bip174/src/lib/converter/varint.js", "../../bip174/src/lib/converter/tools.js", "../../bip174/src/lib/converter/input/witnessUtxo.js", "../../bip174/src/lib/converter/output/tapTree.js", "../../bip174/src/lib/converter/shared/bip32Derivation.js", "../../bip174/src/lib/converter/shared/checkPubkey.js", "../../bip174/src/lib/converter/shared/redeemScript.js", "../../bip174/src/lib/converter/shared/tapBip32Derivation.js", "../../bip174/src/lib/converter/shared/tapInternalKey.js", "../../bip174/src/lib/converter/shared/witnessScript.js", "../../bip174/src/lib/converter/index.js", "../../bip174/src/lib/parser/fromBuffer.js", "../../bip174/src/lib/parser/toBuffer.js", "../../bip174/src/lib/parser/index.js", "../../bip174/src/lib/combiner/index.js", "../../bip174/src/lib/utils.js", "../../bip174/src/lib/psbt.js", "../../bitcoinjs-lib/src/psbt/psbtutils.js", "../../bitcoinjs-lib/src/psbt/bip371.js", "../../bitcoinjs-lib/src/psbt.js", "../../bitcoinjs-lib/src/index.js"],
  "sourcesContent": ["'use strict';\n// https://en.bitcoin.it/wiki/List_of_address_prefixes\n// Dogecoin BIP32 is a proposed standard: https://bitcointalk.org/index.php?topic=409731\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.testnet = exports.regtest = exports.bitcoin = void 0;\n/**\n * Represents the Bitcoin network configuration.\n */\nexports.bitcoin = {\n  /**\n   * The message prefix used for signing Bitcoin messages.\n   */\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  /**\n   * The Bech32 prefix used for Bitcoin addresses.\n   */\n  bech32: 'bc',\n  /**\n   * The BIP32 key prefixes for Bitcoin.\n   */\n  bip32: {\n    /**\n     * The public key prefix for BIP32 extended public keys.\n     */\n    public: 0x0488b21e,\n    /**\n     * The private key prefix for BIP32 extended private keys.\n     */\n    private: 0x0488ade4,\n  },\n  /**\n   * The prefix for Bitcoin public key hashes.\n   */\n  pubKeyHash: 0x00,\n  /**\n   * The prefix for Bitcoin script hashes.\n   */\n  scriptHash: 0x05,\n  /**\n   * The prefix for Bitcoin Wallet Import Format (WIF) private keys.\n   */\n  wif: 0x80,\n};\n/**\n * Represents the regtest network configuration.\n */\nexports.regtest = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'bcrt',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n/**\n * Represents the testnet network configuration.\n */\nexports.testnet = {\n  messagePrefix: '\\x18Bitcoin Signed Message:\\n',\n  bech32: 'tb',\n  bip32: {\n    public: 0x043587cf,\n    private: 0x04358394,\n  },\n  pubKeyHash: 0x6f,\n  scriptHash: 0xc4,\n  wif: 0xef,\n};\n", "'use strict';\n// Reference https://github.com/bitcoin/bips/blob/master/bip-0066.mediawiki\n// Format: 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n// NOTE: SIGHASH byte ignored AND restricted, truncate before use\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = exports.check = void 0;\nfunction check(buffer) {\n  if (buffer.length < 8) return false;\n  if (buffer.length > 72) return false;\n  if (buffer[0] !== 0x30) return false;\n  if (buffer[1] !== buffer.length - 2) return false;\n  if (buffer[2] !== 0x02) return false;\n  const lenR = buffer[3];\n  if (lenR === 0) return false;\n  if (5 + lenR >= buffer.length) return false;\n  if (buffer[4 + lenR] !== 0x02) return false;\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) return false;\n  if (6 + lenR + lenS !== buffer.length) return false;\n  if (buffer[4] & 0x80) return false;\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80)) return false;\n  if (buffer[lenR + 6] & 0x80) return false;\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    return false;\n  return true;\n}\nexports.check = check;\nfunction decode(buffer) {\n  if (buffer.length < 8) throw new Error('DER sequence length is too short');\n  if (buffer.length > 72) throw new Error('DER sequence length is too long');\n  if (buffer[0] !== 0x30) throw new Error('Expected DER sequence');\n  if (buffer[1] !== buffer.length - 2)\n    throw new Error('DER sequence length is invalid');\n  if (buffer[2] !== 0x02) throw new Error('Expected DER integer');\n  const lenR = buffer[3];\n  if (lenR === 0) throw new Error('R length is zero');\n  if (5 + lenR >= buffer.length) throw new Error('R length is too long');\n  if (buffer[4 + lenR] !== 0x02) throw new Error('Expected DER integer (2)');\n  const lenS = buffer[5 + lenR];\n  if (lenS === 0) throw new Error('S length is zero');\n  if (6 + lenR + lenS !== buffer.length) throw new Error('S length is invalid');\n  if (buffer[4] & 0x80) throw new Error('R value is negative');\n  if (lenR > 1 && buffer[4] === 0x00 && !(buffer[5] & 0x80))\n    throw new Error('R value excessively padded');\n  if (buffer[lenR + 6] & 0x80) throw new Error('S value is negative');\n  if (lenS > 1 && buffer[lenR + 6] === 0x00 && !(buffer[lenR + 7] & 0x80))\n    throw new Error('S value excessively padded');\n  // non-BIP66 - extract R, S values\n  return {\n    r: buffer.slice(4, 4 + lenR),\n    s: buffer.slice(6 + lenR),\n  };\n}\nexports.decode = decode;\n/*\n * Expects r and s to be positive DER integers.\n *\n * The DER format uses the most significant bit as a sign bit (& 0x80).\n * If the significant bit is set AND the integer is positive, a 0x00 is prepended.\n *\n * Examples:\n *\n *      0 =>     0x00\n *      1 =>     0x01\n *     -1 =>     0xff\n *    127 =>     0x7f\n *   -127 =>     0x81\n *    128 =>   0x0080\n *   -128 =>     0x80\n *    255 =>   0x00ff\n *   -255 =>   0xff01\n *  16300 =>   0x3fac\n * -16300 =>   0xc054\n *  62300 => 0x00f35c\n * -62300 => 0xff0ca4\n */\nfunction encode(r, s) {\n  const lenR = r.length;\n  const lenS = s.length;\n  if (lenR === 0) throw new Error('R length is zero');\n  if (lenS === 0) throw new Error('S length is zero');\n  if (lenR > 33) throw new Error('R length is too long');\n  if (lenS > 33) throw new Error('S length is too long');\n  if (r[0] & 0x80) throw new Error('R value is negative');\n  if (s[0] & 0x80) throw new Error('S value is negative');\n  if (lenR > 1 && r[0] === 0x00 && !(r[1] & 0x80))\n    throw new Error('R value excessively padded');\n  if (lenS > 1 && s[0] === 0x00 && !(s[1] & 0x80))\n    throw new Error('S value excessively padded');\n  const signature = Buffer.allocUnsafe(6 + lenR + lenS);\n  // 0x30 [total-length] 0x02 [R-length] [R] 0x02 [S-length] [S]\n  signature[0] = 0x30;\n  signature[1] = signature.length - 2;\n  signature[2] = 0x02;\n  signature[3] = r.length;\n  r.copy(signature, 4);\n  signature[4 + lenR] = 0x02;\n  signature[5 + lenR] = s.length;\n  s.copy(signature, 6 + lenR);\n  return signature;\n}\nexports.encode = encode;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.REVERSE_OPS = exports.OPS = void 0;\nconst OPS = {\n  OP_FALSE: 0,\n  OP_0: 0,\n  OP_PUSHDATA1: 76,\n  OP_PUSHDATA2: 77,\n  OP_PUSHDATA4: 78,\n  OP_1NEGATE: 79,\n  OP_RESERVED: 80,\n  OP_TRUE: 81,\n  OP_1: 81,\n  OP_2: 82,\n  OP_3: 83,\n  OP_4: 84,\n  OP_5: 85,\n  OP_6: 86,\n  OP_7: 87,\n  OP_8: 88,\n  OP_9: 89,\n  OP_10: 90,\n  OP_11: 91,\n  OP_12: 92,\n  OP_13: 93,\n  OP_14: 94,\n  OP_15: 95,\n  OP_16: 96,\n  OP_NOP: 97,\n  OP_VER: 98,\n  OP_IF: 99,\n  OP_NOTIF: 100,\n  OP_VERIF: 101,\n  OP_VERNOTIF: 102,\n  OP_ELSE: 103,\n  OP_ENDIF: 104,\n  OP_VERIFY: 105,\n  OP_RETURN: 106,\n  OP_TOALTSTACK: 107,\n  OP_FROMALTSTACK: 108,\n  OP_2DROP: 109,\n  OP_2DUP: 110,\n  OP_3DUP: 111,\n  OP_2OVER: 112,\n  OP_2ROT: 113,\n  OP_2SWAP: 114,\n  OP_IFDUP: 115,\n  OP_DEPTH: 116,\n  OP_DROP: 117,\n  OP_DUP: 118,\n  OP_NIP: 119,\n  OP_OVER: 120,\n  OP_PICK: 121,\n  OP_ROLL: 122,\n  OP_ROT: 123,\n  OP_SWAP: 124,\n  OP_TUCK: 125,\n  OP_CAT: 126,\n  OP_SUBSTR: 127,\n  OP_LEFT: 128,\n  OP_RIGHT: 129,\n  OP_SIZE: 130,\n  OP_INVERT: 131,\n  OP_AND: 132,\n  OP_OR: 133,\n  OP_XOR: 134,\n  OP_EQUAL: 135,\n  OP_EQUALVERIFY: 136,\n  OP_RESERVED1: 137,\n  OP_RESERVED2: 138,\n  OP_1ADD: 139,\n  OP_1SUB: 140,\n  OP_2MUL: 141,\n  OP_2DIV: 142,\n  OP_NEGATE: 143,\n  OP_ABS: 144,\n  OP_NOT: 145,\n  OP_0NOTEQUAL: 146,\n  OP_ADD: 147,\n  OP_SUB: 148,\n  OP_MUL: 149,\n  OP_DIV: 150,\n  OP_MOD: 151,\n  OP_LSHIFT: 152,\n  OP_RSHIFT: 153,\n  OP_BOOLAND: 154,\n  OP_BOOLOR: 155,\n  OP_NUMEQUAL: 156,\n  OP_NUMEQUALVERIFY: 157,\n  OP_NUMNOTEQUAL: 158,\n  OP_LESSTHAN: 159,\n  OP_GREATERTHAN: 160,\n  OP_LESSTHANOREQUAL: 161,\n  OP_GREATERTHANOREQUAL: 162,\n  OP_MIN: 163,\n  OP_MAX: 164,\n  OP_WITHIN: 165,\n  OP_RIPEMD160: 166,\n  OP_SHA1: 167,\n  OP_SHA256: 168,\n  OP_HASH160: 169,\n  OP_HASH256: 170,\n  OP_CODESEPARATOR: 171,\n  OP_CHECKSIG: 172,\n  OP_CHECKSIGVERIFY: 173,\n  OP_CHECKMULTISIG: 174,\n  OP_CHECKMULTISIGVERIFY: 175,\n  OP_NOP1: 176,\n  OP_NOP2: 177,\n  OP_CHECKLOCKTIMEVERIFY: 177,\n  OP_NOP3: 178,\n  OP_CHECKSEQUENCEVERIFY: 178,\n  OP_NOP4: 179,\n  OP_NOP5: 180,\n  OP_NOP6: 181,\n  OP_NOP7: 182,\n  OP_NOP8: 183,\n  OP_NOP9: 184,\n  OP_NOP10: 185,\n  OP_CHECKSIGADD: 186,\n  OP_PUBKEYHASH: 253,\n  OP_PUBKEY: 254,\n  OP_INVALIDOPCODE: 255,\n};\nexports.OPS = OPS;\nconst REVERSE_OPS = {};\nexports.REVERSE_OPS = REVERSE_OPS;\nfor (const op of Object.keys(OPS)) {\n  const code = OPS[op];\n  REVERSE_OPS[code] = op;\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.decode = exports.encode = exports.encodingLength = void 0;\nconst ops_1 = require('./ops');\n/**\n * Calculates the encoding length of a number used for push data in Bitcoin transactions.\n * @param i The number to calculate the encoding length for.\n * @returns The encoding length of the number.\n */\nfunction encodingLength(i) {\n  return i < ops_1.OPS.OP_PUSHDATA1 ? 1 : i <= 0xff ? 2 : i <= 0xffff ? 3 : 5;\n}\nexports.encodingLength = encodingLength;\n/**\n * Encodes a number into a buffer using a variable-length encoding scheme.\n * The encoded buffer is written starting at the specified offset.\n * Returns the size of the encoded buffer.\n *\n * @param buffer - The buffer to write the encoded data into.\n * @param num - The number to encode.\n * @param offset - The offset at which to start writing the encoded buffer.\n * @returns The size of the encoded buffer.\n */\nfunction encode(buffer, num, offset) {\n  const size = encodingLength(num);\n  // ~6 bit\n  if (size === 1) {\n    buffer.writeUInt8(num, offset);\n    // 8 bit\n  } else if (size === 2) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA1, offset);\n    buffer.writeUInt8(num, offset + 1);\n    // 16 bit\n  } else if (size === 3) {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA2, offset);\n    buffer.writeUInt16LE(num, offset + 1);\n    // 32 bit\n  } else {\n    buffer.writeUInt8(ops_1.OPS.OP_PUSHDATA4, offset);\n    buffer.writeUInt32LE(num, offset + 1);\n  }\n  return size;\n}\nexports.encode = encode;\n/**\n * Decodes a buffer and returns information about the opcode, number, and size.\n * @param buffer - The buffer to decode.\n * @param offset - The offset within the buffer to start decoding.\n * @returns An object containing the opcode, number, and size, or null if decoding fails.\n */\nfunction decode(buffer, offset) {\n  const opcode = buffer.readUInt8(offset);\n  let num;\n  let size;\n  // ~6 bit\n  if (opcode < ops_1.OPS.OP_PUSHDATA1) {\n    num = opcode;\n    size = 1;\n    // 8 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA1) {\n    if (offset + 2 > buffer.length) return null;\n    num = buffer.readUInt8(offset + 1);\n    size = 2;\n    // 16 bit\n  } else if (opcode === ops_1.OPS.OP_PUSHDATA2) {\n    if (offset + 3 > buffer.length) return null;\n    num = buffer.readUInt16LE(offset + 1);\n    size = 3;\n    // 32 bit\n  } else {\n    if (offset + 5 > buffer.length) return null;\n    if (opcode !== ops_1.OPS.OP_PUSHDATA4) throw new Error('Unexpected opcode');\n    num = buffer.readUInt32LE(offset + 1);\n    size = 5;\n  }\n  return {\n    opcode,\n    number: num,\n    size,\n  };\n}\nexports.decode = decode;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\n/**\n * Decodes a script number from a buffer.\n *\n * @param buffer - The buffer containing the script number.\n * @param maxLength - The maximum length of the script number. Defaults to 4.\n * @param minimal - Whether the script number should be minimal. Defaults to true.\n * @returns The decoded script number.\n * @throws {TypeError} If the script number overflows the maximum length.\n * @throws {Error} If the script number is not minimally encoded when minimal is true.\n */\nfunction decode(buffer, maxLength, minimal) {\n  maxLength = maxLength || 4;\n  minimal = minimal === undefined ? true : minimal;\n  const length = buffer.length;\n  if (length === 0) return 0;\n  if (length > maxLength) throw new TypeError('Script number overflow');\n  if (minimal) {\n    if ((buffer[length - 1] & 0x7f) === 0) {\n      if (length <= 1 || (buffer[length - 2] & 0x80) === 0)\n        throw new Error('Non-minimally encoded script number');\n    }\n  }\n  // 40-bit\n  if (length === 5) {\n    const a = buffer.readUInt32LE(0);\n    const b = buffer.readUInt8(4);\n    if (b & 0x80) return -((b & ~0x80) * 0x100000000 + a);\n    return b * 0x100000000 + a;\n  }\n  // 32-bit / 24-bit / 16-bit / 8-bit\n  let result = 0;\n  for (let i = 0; i < length; ++i) {\n    result |= buffer[i] << (8 * i);\n  }\n  if (buffer[length - 1] & 0x80)\n    return -(result & ~(0x80 << (8 * (length - 1))));\n  return result;\n}\nexports.decode = decode;\nfunction scriptNumSize(i) {\n  return i > 0x7fffffff\n    ? 5\n    : i > 0x7fffff\n    ? 4\n    : i > 0x7fff\n    ? 3\n    : i > 0x7f\n    ? 2\n    : i > 0x00\n    ? 1\n    : 0;\n}\n/**\n * Encodes a number into a Buffer using a specific format.\n *\n * @param _number - The number to encode.\n * @returns The encoded number as a Buffer.\n */\nfunction encode(_number) {\n  let value = Math.abs(_number);\n  const size = scriptNumSize(value);\n  const buffer = Buffer.allocUnsafe(size);\n  const negative = _number < 0;\n  for (let i = 0; i < size; ++i) {\n    buffer.writeUInt8(value & 0xff, i);\n    value >>= 8;\n  }\n  if (buffer[size - 1] & 0x80) {\n    buffer.writeUInt8(negative ? 0x80 : 0x00, size - 1);\n  } else if (negative) {\n    buffer[size - 1] |= 0x80;\n  }\n  return buffer;\n}\nexports.encode = encode;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.oneOf =\n  exports.Null =\n  exports.BufferN =\n  exports.Function =\n  exports.UInt32 =\n  exports.UInt8 =\n  exports.tuple =\n  exports.maybe =\n  exports.Hex =\n  exports.Buffer =\n  exports.String =\n  exports.Boolean =\n  exports.Array =\n  exports.Number =\n  exports.Hash256bit =\n  exports.Hash160bit =\n  exports.Buffer256bit =\n  exports.isTaptree =\n  exports.isTapleaf =\n  exports.TAPLEAF_VERSION_MASK =\n  exports.Satoshi =\n  exports.isPoint =\n  exports.stacksEqual =\n  exports.typeforce =\n    void 0;\nconst buffer_1 = require('buffer');\nexports.typeforce = require('typeforce');\nconst ZERO32 = buffer_1.Buffer.alloc(32, 0);\nconst EC_P = buffer_1.Buffer.from(\n  'fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f',\n  'hex',\n);\n/**\n * Checks if two arrays of Buffers are equal.\n * @param a - The first array of Buffers.\n * @param b - The second array of Buffers.\n * @returns True if the arrays are equal, false otherwise.\n */\nfunction stacksEqual(a, b) {\n  if (a.length !== b.length) return false;\n  return a.every((x, i) => {\n    return x.equals(b[i]);\n  });\n}\nexports.stacksEqual = stacksEqual;\n/**\n * Checks if the given value is a valid elliptic curve point.\n * @param p - The value to check.\n * @returns True if the value is a valid elliptic curve point, false otherwise.\n */\nfunction isPoint(p) {\n  if (!buffer_1.Buffer.isBuffer(p)) return false;\n  if (p.length < 33) return false;\n  const t = p[0];\n  const x = p.slice(1, 33);\n  if (x.compare(ZERO32) === 0) return false;\n  if (x.compare(EC_P) >= 0) return false;\n  if ((t === 0x02 || t === 0x03) && p.length === 33) {\n    return true;\n  }\n  const y = p.slice(33);\n  if (y.compare(ZERO32) === 0) return false;\n  if (y.compare(EC_P) >= 0) return false;\n  if (t === 0x04 && p.length === 65) return true;\n  return false;\n}\nexports.isPoint = isPoint;\nconst SATOSHI_MAX = 21 * 1e14;\nfunction Satoshi(value) {\n  return exports.typeforce.UInt53(value) && value <= SATOSHI_MAX;\n}\nexports.Satoshi = Satoshi;\nexports.TAPLEAF_VERSION_MASK = 0xfe;\nfunction isTapleaf(o) {\n  if (!o || !('output' in o)) return false;\n  if (!buffer_1.Buffer.isBuffer(o.output)) return false;\n  if (o.version !== undefined)\n    return (o.version & exports.TAPLEAF_VERSION_MASK) === o.version;\n  return true;\n}\nexports.isTapleaf = isTapleaf;\nfunction isTaptree(scriptTree) {\n  if (!(0, exports.Array)(scriptTree)) return isTapleaf(scriptTree);\n  if (scriptTree.length !== 2) return false;\n  return scriptTree.every(t => isTaptree(t));\n}\nexports.isTaptree = isTaptree;\nexports.Buffer256bit = exports.typeforce.BufferN(32);\nexports.Hash160bit = exports.typeforce.BufferN(20);\nexports.Hash256bit = exports.typeforce.BufferN(32);\nexports.Number = exports.typeforce.Number;\nexports.Array = exports.typeforce.Array;\nexports.Boolean = exports.typeforce.Boolean;\nexports.String = exports.typeforce.String;\nexports.Buffer = exports.typeforce.Buffer;\nexports.Hex = exports.typeforce.Hex;\nexports.maybe = exports.typeforce.maybe;\nexports.tuple = exports.typeforce.tuple;\nexports.UInt8 = exports.typeforce.UInt8;\nexports.UInt32 = exports.typeforce.UInt32;\nexports.Function = exports.typeforce.Function;\nexports.BufferN = exports.typeforce.BufferN;\nexports.Null = exports.typeforce.Null;\nexports.oneOf = exports.typeforce.oneOf;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.encode = exports.decode = void 0;\nconst bip66 = require('./bip66');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nconst ZERO = Buffer.alloc(1, 0);\n/**\n * Converts a buffer to a DER-encoded buffer.\n * @param x - The buffer to be converted.\n * @returns The DER-encoded buffer.\n */\nfunction toDER(x) {\n  let i = 0;\n  while (x[i] === 0) ++i;\n  if (i === x.length) return ZERO;\n  x = x.slice(i);\n  if (x[0] & 0x80) return Buffer.concat([ZERO, x], 1 + x.length);\n  return x;\n}\n/**\n * Converts a DER-encoded signature to a buffer.\n * If the first byte of the input buffer is 0x00, it is skipped.\n * The resulting buffer is 32 bytes long, filled with zeros if necessary.\n * @param x - The DER-encoded signature.\n * @returns The converted buffer.\n */\nfunction fromDER(x) {\n  if (x[0] === 0x00) x = x.slice(1);\n  const buffer = Buffer.alloc(32, 0);\n  const bstart = Math.max(0, 32 - x.length);\n  x.copy(buffer, bstart);\n  return buffer;\n}\n// BIP62: 1 byte hashType flag (only 0x01, 0x02, 0x03, 0x81, 0x82 and 0x83 are allowed)\n/**\n * Decodes a buffer into a ScriptSignature object.\n * @param buffer - The buffer to decode.\n * @returns The decoded ScriptSignature object.\n * @throws Error if the hashType is invalid.\n */\nfunction decode(buffer) {\n  const hashType = buffer.readUInt8(buffer.length - 1);\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const decoded = bip66.decode(buffer.slice(0, -1));\n  const r = fromDER(decoded.r);\n  const s = fromDER(decoded.s);\n  const signature = Buffer.concat([r, s], 64);\n  return { signature, hashType };\n}\nexports.decode = decode;\n/**\n * Encodes a signature and hash type into a buffer.\n * @param signature - The signature to encode.\n * @param hashType - The hash type to encode.\n * @returns The encoded buffer.\n * @throws Error if the hashType is invalid.\n */\nfunction encode(signature, hashType) {\n  typeforce(\n    {\n      signature: types.BufferN(64),\n      hashType: types.UInt8,\n    },\n    { signature, hashType },\n  );\n  if (!(0, script_1.isDefinedHashType)(hashType)) {\n    throw new Error('Invalid hashType ' + hashType);\n  }\n  const hashTypeBuffer = Buffer.allocUnsafe(1);\n  hashTypeBuffer.writeUInt8(hashType, 0);\n  const r = toDER(signature.slice(0, 32));\n  const s = toDER(signature.slice(32, 64));\n  return Buffer.concat([bip66.encode(r, s), hashTypeBuffer]);\n}\nexports.encode = encode;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signature =\n  exports.number =\n  exports.isCanonicalScriptSignature =\n  exports.isDefinedHashType =\n  exports.isCanonicalPubKey =\n  exports.toStack =\n  exports.fromASM =\n  exports.toASM =\n  exports.decompile =\n  exports.compile =\n  exports.countNonPushOnlyOPs =\n  exports.isPushOnly =\n  exports.OPS =\n    void 0;\n/**\n * Script tools, including decompile, compile, toASM, fromASM, toStack, isCanonicalPubKey, isCanonicalScriptSignature\n * @packageDocumentation\n */\nconst bip66 = require('./bip66');\nconst ops_1 = require('./ops');\nObject.defineProperty(exports, 'OPS', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nconst pushdata = require('./push_data');\nconst scriptNumber = require('./script_number');\nconst scriptSignature = require('./script_signature');\nconst types = require('./types');\nconst { typeforce } = types;\nconst OP_INT_BASE = ops_1.OPS.OP_RESERVED; // OP_1 - 1\nfunction isOPInt(value) {\n  return (\n    types.Number(value) &&\n    (value === ops_1.OPS.OP_0 ||\n      (value >= ops_1.OPS.OP_1 && value <= ops_1.OPS.OP_16) ||\n      value === ops_1.OPS.OP_1NEGATE)\n  );\n}\nfunction isPushOnlyChunk(value) {\n  return types.Buffer(value) || isOPInt(value);\n}\nfunction isPushOnly(value) {\n  return types.Array(value) && value.every(isPushOnlyChunk);\n}\nexports.isPushOnly = isPushOnly;\nfunction countNonPushOnlyOPs(value) {\n  return value.length - value.filter(isPushOnlyChunk).length;\n}\nexports.countNonPushOnlyOPs = countNonPushOnlyOPs;\nfunction asMinimalOP(buffer) {\n  if (buffer.length === 0) return ops_1.OPS.OP_0;\n  if (buffer.length !== 1) return;\n  if (buffer[0] >= 1 && buffer[0] <= 16) return OP_INT_BASE + buffer[0];\n  if (buffer[0] === 0x81) return ops_1.OPS.OP_1NEGATE;\n}\nfunction chunksIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\nfunction chunksIsArray(buf) {\n  return types.Array(buf);\n}\nfunction singleChunkIsBuffer(buf) {\n  return Buffer.isBuffer(buf);\n}\n/**\n * Compiles an array of chunks into a Buffer.\n *\n * @param chunks - The array of chunks to compile.\n * @returns The compiled Buffer.\n * @throws Error if the compilation fails.\n */\nfunction compile(chunks) {\n  // TODO: remove me\n  if (chunksIsBuffer(chunks)) return chunks;\n  typeforce(types.Array, chunks);\n  const bufferSize = chunks.reduce((accum, chunk) => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      if (chunk.length === 1 && asMinimalOP(chunk) !== undefined) {\n        return accum + 1;\n      }\n      return accum + pushdata.encodingLength(chunk.length) + chunk.length;\n    }\n    // opcode\n    return accum + 1;\n  }, 0.0);\n  const buffer = Buffer.allocUnsafe(bufferSize);\n  let offset = 0;\n  chunks.forEach(chunk => {\n    // data chunk\n    if (singleChunkIsBuffer(chunk)) {\n      // adhere to BIP62.3, minimal push policy\n      const opcode = asMinimalOP(chunk);\n      if (opcode !== undefined) {\n        buffer.writeUInt8(opcode, offset);\n        offset += 1;\n        return;\n      }\n      offset += pushdata.encode(buffer, chunk.length, offset);\n      chunk.copy(buffer, offset);\n      offset += chunk.length;\n      // opcode\n    } else {\n      buffer.writeUInt8(chunk, offset);\n      offset += 1;\n    }\n  });\n  if (offset !== buffer.length) throw new Error('Could not decode chunks');\n  return buffer;\n}\nexports.compile = compile;\nfunction decompile(buffer) {\n  // TODO: remove me\n  if (chunksIsArray(buffer)) return buffer;\n  typeforce(types.Buffer, buffer);\n  const chunks = [];\n  let i = 0;\n  while (i < buffer.length) {\n    const opcode = buffer[i];\n    // data chunk\n    if (opcode > ops_1.OPS.OP_0 && opcode <= ops_1.OPS.OP_PUSHDATA4) {\n      const d = pushdata.decode(buffer, i);\n      // did reading a pushDataInt fail?\n      if (d === null) return null;\n      i += d.size;\n      // attempt to read too much data?\n      if (i + d.number > buffer.length) return null;\n      const data = buffer.slice(i, i + d.number);\n      i += d.number;\n      // decompile minimally\n      const op = asMinimalOP(data);\n      if (op !== undefined) {\n        chunks.push(op);\n      } else {\n        chunks.push(data);\n      }\n      // opcode\n    } else {\n      chunks.push(opcode);\n      i += 1;\n    }\n  }\n  return chunks;\n}\nexports.decompile = decompile;\n/**\n * Converts the given chunks into an ASM (Assembly) string representation.\n * If the chunks parameter is a Buffer, it will be decompiled into a Stack before conversion.\n * @param chunks - The chunks to convert into ASM.\n * @returns The ASM string representation of the chunks.\n */\nfunction toASM(chunks) {\n  if (chunksIsBuffer(chunks)) {\n    chunks = decompile(chunks);\n  }\n  if (!chunks) {\n    throw new Error('Could not convert invalid chunks to ASM');\n  }\n  return chunks\n    .map(chunk => {\n      // data?\n      if (singleChunkIsBuffer(chunk)) {\n        const op = asMinimalOP(chunk);\n        if (op === undefined) return chunk.toString('hex');\n        chunk = op;\n      }\n      // opcode!\n      return ops_1.REVERSE_OPS[chunk];\n    })\n    .join(' ');\n}\nexports.toASM = toASM;\n/**\n * Converts an ASM string to a Buffer.\n * @param asm The ASM string to convert.\n * @returns The converted Buffer.\n */\nfunction fromASM(asm) {\n  typeforce(types.String, asm);\n  return compile(\n    asm.split(' ').map(chunkStr => {\n      // opcode?\n      if (ops_1.OPS[chunkStr] !== undefined) return ops_1.OPS[chunkStr];\n      typeforce(types.Hex, chunkStr);\n      // data!\n      return Buffer.from(chunkStr, 'hex');\n    }),\n  );\n}\nexports.fromASM = fromASM;\n/**\n * Converts the given chunks into a stack of buffers.\n *\n * @param chunks - The chunks to convert.\n * @returns The stack of buffers.\n */\nfunction toStack(chunks) {\n  chunks = decompile(chunks);\n  typeforce(isPushOnly, chunks);\n  return chunks.map(op => {\n    if (singleChunkIsBuffer(op)) return op;\n    if (op === ops_1.OPS.OP_0) return Buffer.allocUnsafe(0);\n    return scriptNumber.encode(op - OP_INT_BASE);\n  });\n}\nexports.toStack = toStack;\nfunction isCanonicalPubKey(buffer) {\n  return types.isPoint(buffer);\n}\nexports.isCanonicalPubKey = isCanonicalPubKey;\nfunction isDefinedHashType(hashType) {\n  const hashTypeMod = hashType & ~0x80;\n  // return hashTypeMod > SIGHASH_ALL && hashTypeMod < SIGHASH_SINGLE\n  return hashTypeMod > 0x00 && hashTypeMod < 0x04;\n}\nexports.isDefinedHashType = isDefinedHashType;\nfunction isCanonicalScriptSignature(buffer) {\n  if (!Buffer.isBuffer(buffer)) return false;\n  if (!isDefinedHashType(buffer[buffer.length - 1])) return false;\n  return bip66.check(buffer.slice(0, -1));\n}\nexports.isCanonicalScriptSignature = isCanonicalScriptSignature;\nexports.number = scriptNumber;\nexports.signature = scriptSignature;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.value = exports.prop = void 0;\nfunction prop(object, name, f) {\n  Object.defineProperty(object, name, {\n    configurable: true,\n    enumerable: true,\n    get() {\n      const _value = f.call(this);\n      this[name] = _value;\n      return _value;\n    },\n    set(_value) {\n      Object.defineProperty(this, name, {\n        configurable: true,\n        enumerable: true,\n        value: _value,\n        writable: true,\n      });\n    },\n  });\n}\nexports.prop = prop;\nfunction value(f) {\n  let _value;\n  return () => {\n    if (_value !== undefined) return _value;\n    _value = f();\n    return _value;\n  };\n}\nexports.value = value;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2data = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// output: OP_RETURN ...\n/**\n * Embeds data in a Bitcoin payment.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The modified payment object.\n * @throws {TypeError} If there is not enough data or if the output is invalid.\n */\nfunction p2data(a, opts) {\n  if (!a.data && !a.output) throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      data: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'embed', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.data) return;\n    return bscript.compile([OPS.OP_RETURN].concat(a.data));\n  });\n  lazy.prop(o, 'data', () => {\n    if (!a.output) return;\n    return bscript.decompile(a.output).slice(1);\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      const chunks = bscript.decompile(a.output);\n      if (chunks[0] !== OPS.OP_RETURN) throw new TypeError('Output is invalid');\n      if (!chunks.slice(1).every(types_1.typeforce.Buffer))\n        throw new TypeError('Output is invalid');\n      if (a.data && !(0, types_1.stacksEqual)(a.data, o.data))\n        throw new TypeError('Data mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2data = p2data;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2ms = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\nconst OP_INT_BASE = OPS.OP_RESERVED; // OP_1 - 1\n// input: OP_0 [signatures ...]\n// output: m [pubKeys ...] n OP_CHECKMULTISIG\n/**\n * Represents a function that creates a Pay-to-Multisig (P2MS) payment object.\n * @param a - The payment object.\n * @param opts - Optional payment options.\n * @returns The created payment object.\n * @throws {TypeError} If the provided data is not valid.\n */\nfunction p2ms(a, opts) {\n  if (\n    !a.input &&\n    !a.output &&\n    !(a.pubkeys && a.m !== undefined) &&\n    !a.signatures\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  function isAcceptableSignature(x) {\n    return (\n      bscript.isCanonicalScriptSignature(x) ||\n      (opts.allowIncomplete && x === OPS.OP_0) !== undefined\n    );\n  }\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      m: types_1.typeforce.maybe(types_1.typeforce.Number),\n      n: types_1.typeforce.maybe(types_1.typeforce.Number),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkeys: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.isPoint),\n      ),\n      signatures: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(isAcceptableSignature),\n      ),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const network = a.network || networks_1.bitcoin;\n  const o = { network };\n  let chunks = [];\n  let decoded = false;\n  function decode(output) {\n    if (decoded) return;\n    decoded = true;\n    chunks = bscript.decompile(output);\n    o.m = chunks[0] - OP_INT_BASE;\n    o.n = chunks[chunks.length - 2] - OP_INT_BASE;\n    o.pubkeys = chunks.slice(1, -2);\n  }\n  lazy.prop(o, 'output', () => {\n    if (!a.m) return;\n    if (!o.n) return;\n    if (!a.pubkeys) return;\n    return bscript.compile(\n      [].concat(\n        OP_INT_BASE + a.m,\n        a.pubkeys,\n        OP_INT_BASE + o.n,\n        OPS.OP_CHECKMULTISIG,\n      ),\n    );\n  });\n  lazy.prop(o, 'm', () => {\n    if (!o.output) return;\n    decode(o.output);\n    return o.m;\n  });\n  lazy.prop(o, 'n', () => {\n    if (!o.pubkeys) return;\n    return o.pubkeys.length;\n  });\n  lazy.prop(o, 'pubkeys', () => {\n    if (!a.output) return;\n    decode(a.output);\n    return o.pubkeys;\n  });\n  lazy.prop(o, 'signatures', () => {\n    if (!a.input) return;\n    return bscript.decompile(a.input).slice(1);\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signatures) return;\n    return bscript.compile([OPS.OP_0].concat(a.signatures));\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  lazy.prop(o, 'name', () => {\n    if (!o.m || !o.n) return;\n    return `p2ms(${o.m} of ${o.n})`;\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      decode(a.output);\n      if (!types_1.typeforce.Number(chunks[0]))\n        throw new TypeError('Output is invalid');\n      if (!types_1.typeforce.Number(chunks[chunks.length - 2]))\n        throw new TypeError('Output is invalid');\n      if (chunks[chunks.length - 1] !== OPS.OP_CHECKMULTISIG)\n        throw new TypeError('Output is invalid');\n      if (o.m <= 0 || o.n > 16 || o.m > o.n || o.n !== chunks.length - 3)\n        throw new TypeError('Output is invalid');\n      if (!o.pubkeys.every(x => (0, types_1.isPoint)(x)))\n        throw new TypeError('Output is invalid');\n      if (a.m !== undefined && a.m !== o.m) throw new TypeError('m mismatch');\n      if (a.n !== undefined && a.n !== o.n) throw new TypeError('n mismatch');\n      if (a.pubkeys && !(0, types_1.stacksEqual)(a.pubkeys, o.pubkeys))\n        throw new TypeError('Pubkeys mismatch');\n    }\n    if (a.pubkeys) {\n      if (a.n !== undefined && a.n !== a.pubkeys.length)\n        throw new TypeError('Pubkey count mismatch');\n      o.n = a.pubkeys.length;\n      if (o.n < o.m) throw new TypeError('Pubkey count cannot be less than m');\n    }\n    if (a.signatures) {\n      if (a.signatures.length < o.m)\n        throw new TypeError('Not enough signatures provided');\n      if (a.signatures.length > o.m)\n        throw new TypeError('Too many signatures provided');\n    }\n    if (a.input) {\n      if (a.input[0] !== OPS.OP_0) throw new TypeError('Input is invalid');\n      if (\n        o.signatures.length === 0 ||\n        !o.signatures.every(isAcceptableSignature)\n      )\n        throw new TypeError('Input has invalid signature(s)');\n      if (a.signatures && !(0, types_1.stacksEqual)(a.signatures, o.signatures))\n        throw new TypeError('Signature mismatch');\n      if (a.m !== undefined && a.m !== a.signatures.length)\n        throw new TypeError('Signature count mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2ms = p2ms;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pk = void 0;\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst OPS = bscript.OPS;\n// input: {signature}\n// output: {pubKey} OP_CHECKSIG\n/**\n * Creates a pay-to-public-key (P2PK) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PK payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pk(a, opts) {\n  if (!a.input && !a.output && !a.pubkey && !a.input && !a.signature)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pk', network };\n  lazy.prop(o, 'output', () => {\n    if (!a.pubkey) return;\n    return bscript.compile([a.pubkey, OPS.OP_CHECKSIG]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.output) return;\n    return a.output.slice(1, -1);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.signature) return;\n    return bscript.compile([a.signature]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    if (a.output) {\n      if (a.output[a.output.length - 1] !== OPS.OP_CHECKSIG)\n        throw new TypeError('Output is invalid');\n      if (!(0, types_1.isPoint)(o.pubkey))\n        throw new TypeError('Output pubkey is invalid');\n      if (a.pubkey && !a.pubkey.equals(o.pubkey))\n        throw new TypeError('Pubkey mismatch');\n    }\n    if (a.signature) {\n      if (a.input && !a.input.equals(o.input))\n        throw new TypeError('Signature mismatch');\n    }\n    if (a.input) {\n      if (_chunks().length !== 1) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(o.signature))\n        throw new TypeError('Input has invalid signature');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pk = p2pk;\n", "/**\n * SHA1 (RFC 3174) legacy hash function.\n * @module\n * @deprecated\n */\nimport { SHA1 as SHA1n, sha1 as sha1n } from './legacy.ts';\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const SHA1: typeof SHA1n = SHA1n;\n/** @deprecated Use import from `noble/hashes/legacy` module */\nexport const sha1: typeof sha1n = sha1n;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.taggedHash =\n  exports.TAGGED_HASH_PREFIXES =\n  exports.TAGS =\n  exports.hash256 =\n  exports.hash160 =\n  exports.sha256 =\n  exports.sha1 =\n  exports.ripemd160 =\n    void 0;\n/**\n * A module for hashing functions.\n * include ripemd160、sha1、sha256、hash160、hash256、taggedHash\n *\n * @packageDocumentation\n */\nconst ripemd160_1 = require('@noble/hashes/ripemd160');\nconst sha1_1 = require('@noble/hashes/sha1');\nconst sha256_1 = require('@noble/hashes/sha256');\nfunction ripemd160(buffer) {\n  return Buffer.from((0, ripemd160_1.ripemd160)(Uint8Array.from(buffer)));\n}\nexports.ripemd160 = ripemd160;\nfunction sha1(buffer) {\n  return Buffer.from((0, sha1_1.sha1)(Uint8Array.from(buffer)));\n}\nexports.sha1 = sha1;\nfunction sha256(buffer) {\n  return Buffer.from((0, sha256_1.sha256)(Uint8Array.from(buffer)));\n}\nexports.sha256 = sha256;\nfunction hash160(buffer) {\n  return Buffer.from(\n    (0, ripemd160_1.ripemd160)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash160 = hash160;\nfunction hash256(buffer) {\n  return Buffer.from(\n    (0, sha256_1.sha256)((0, sha256_1.sha256)(Uint8Array.from(buffer))),\n  );\n}\nexports.hash256 = hash256;\nexports.TAGS = [\n  'BIP0340/challenge',\n  'BIP0340/aux',\n  'BIP0340/nonce',\n  'TapLeaf',\n  'TapBranch',\n  'TapSighash',\n  'TapTweak',\n  'KeyAgg list',\n  'KeyAgg coefficient',\n];\n/** An object mapping tags to their tagged hash prefix of [SHA256(tag) | SHA256(tag)] */\n/**\n * Defines the tagged hash prefixes used in the crypto module.\n */\nexports.TAGGED_HASH_PREFIXES = {\n  'BIP0340/challenge': Buffer.from([\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n    123, 181, 45, 122, 159, 239, 88, 50, 62, 177, 191, 122, 64, 125, 179, 130,\n    210, 243, 242, 216, 27, 177, 34, 79, 73, 254, 81, 143, 109, 72, 211, 124,\n  ]),\n  'BIP0340/aux': Buffer.from([\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n    241, 239, 78, 94, 192, 99, 202, 218, 109, 148, 202, 250, 157, 152, 126, 160,\n    105, 38, 88, 57, 236, 193, 31, 151, 45, 119, 165, 46, 216, 193, 204, 144,\n  ]),\n  'BIP0340/nonce': Buffer.from([\n    7, 73, 119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244,\n    52, 215, 62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47, 7, 73,\n    119, 52, 167, 155, 203, 53, 91, 155, 140, 125, 3, 79, 18, 28, 244, 52, 215,\n    62, 247, 45, 218, 25, 135, 0, 97, 251, 82, 191, 235, 47,\n  ]),\n  TapLeaf: Buffer.from([\n    174, 234, 143, 220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211,\n    95, 28, 181, 64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238, 174, 234, 143,\n    220, 66, 8, 152, 49, 5, 115, 75, 88, 8, 29, 30, 38, 56, 211, 95, 28, 181,\n    64, 8, 212, 211, 87, 202, 3, 190, 120, 233, 238,\n  ]),\n  TapBranch: Buffer.from([\n    25, 65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247,\n    33, 111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21, 25,\n    65, 161, 242, 229, 110, 185, 95, 162, 169, 241, 148, 190, 92, 1, 247, 33,\n    111, 51, 237, 130, 176, 145, 70, 52, 144, 208, 91, 245, 22, 160, 21,\n  ]),\n  TapSighash: Buffer.from([\n    244, 10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61,\n    149, 253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49, 244,\n    10, 72, 223, 75, 42, 112, 200, 180, 146, 75, 242, 101, 70, 97, 237, 61, 149,\n    253, 102, 163, 19, 235, 135, 35, 117, 151, 198, 40, 228, 160, 49,\n  ]),\n  TapTweak: Buffer.from([\n    232, 15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66,\n    156, 188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233, 232,\n    15, 225, 99, 156, 156, 160, 80, 227, 175, 27, 57, 193, 67, 198, 62, 66, 156,\n    188, 235, 21, 217, 64, 251, 181, 197, 161, 244, 175, 87, 197, 233,\n  ]),\n  'KeyAgg list': Buffer.from([\n    72, 28, 151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126,\n    215, 49, 156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240, 72, 28,\n    151, 28, 60, 11, 70, 215, 240, 178, 117, 174, 89, 141, 78, 44, 126, 215, 49,\n    156, 89, 74, 92, 110, 199, 158, 160, 212, 153, 2, 148, 240,\n  ]),\n  'KeyAgg coefficient': Buffer.from([\n    191, 201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100,\n    130, 78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129, 191,\n    201, 4, 3, 77, 28, 136, 232, 200, 14, 34, 229, 61, 36, 86, 109, 100, 130,\n    78, 214, 66, 114, 129, 192, 145, 0, 249, 77, 205, 82, 201, 129,\n  ]),\n};\nfunction taggedHash(prefix, data) {\n  return sha256(Buffer.concat([exports.TAGGED_HASH_PREFIXES[prefix], data]));\n}\nexports.taggedHash = taggedHash;\n", "'use strict'\n// base-x encoding / decoding\n// Copyright (c) 2018 base-x contributors\n// Copyright (c) 2014-2018 The Bitcoin Core developers (base58.cpp)\n// Distributed under the MIT software license, see the accompanying\n// file LICENSE or http://www.opensource.org/licenses/mit-license.php.\nfunction base (ALPHABET) {\n  if (ALPHABET.length >= 255) { throw new TypeError('Alphabet too long') }\n  var BASE_MAP = new Uint8Array(256)\n  for (var j = 0; j < BASE_MAP.length; j++) {\n    BASE_MAP[j] = 255\n  }\n  for (var i = 0; i < ALPHABET.length; i++) {\n    var x = ALPHABET.charAt(i)\n    var xc = x.charCodeAt(0)\n    if (BASE_MAP[xc] !== 255) { throw new TypeError(x + ' is ambiguous') }\n    BASE_MAP[xc] = i\n  }\n  var BASE = ALPHABET.length\n  var LEADER = ALPHABET.charAt(0)\n  var FACTOR = Math.log(BASE) / Math.log(256) // log(BASE) / log(256), rounded up\n  var iFACTOR = Math.log(256) / Math.log(BASE) // log(256) / log(BASE), rounded up\n  function encode (source) {\n    if (source instanceof Uint8Array) {\n    } else if (ArrayBuffer.isView(source)) {\n      source = new Uint8Array(source.buffer, source.byteOffset, source.byteLength)\n    } else if (Array.isArray(source)) {\n      source = Uint8Array.from(source)\n    }\n    if (!(source instanceof Uint8Array)) { throw new TypeError('Expected Uint8Array') }\n    if (source.length === 0) { return '' }\n        // Skip & count leading zeroes.\n    var zeroes = 0\n    var length = 0\n    var pbegin = 0\n    var pend = source.length\n    while (pbegin !== pend && source[pbegin] === 0) {\n      pbegin++\n      zeroes++\n    }\n        // Allocate enough space in big-endian base58 representation.\n    var size = ((pend - pbegin) * iFACTOR + 1) >>> 0\n    var b58 = new Uint8Array(size)\n        // Process the bytes.\n    while (pbegin !== pend) {\n      var carry = source[pbegin]\n            // Apply \"b58 = b58 * 256 + ch\".\n      var i = 0\n      for (var it1 = size - 1; (carry !== 0 || i < length) && (it1 !== -1); it1--, i++) {\n        carry += (256 * b58[it1]) >>> 0\n        b58[it1] = (carry % BASE) >>> 0\n        carry = (carry / BASE) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      pbegin++\n    }\n        // Skip leading zeroes in base58 result.\n    var it2 = size - length\n    while (it2 !== size && b58[it2] === 0) {\n      it2++\n    }\n        // Translate the result into a string.\n    var str = LEADER.repeat(zeroes)\n    for (; it2 < size; ++it2) { str += ALPHABET.charAt(b58[it2]) }\n    return str\n  }\n  function decodeUnsafe (source) {\n    if (typeof source !== 'string') { throw new TypeError('Expected String') }\n    if (source.length === 0) { return new Uint8Array() }\n    var psz = 0\n        // Skip and count leading '1's.\n    var zeroes = 0\n    var length = 0\n    while (source[psz] === LEADER) {\n      zeroes++\n      psz++\n    }\n        // Allocate enough space in big-endian base256 representation.\n    var size = (((source.length - psz) * FACTOR) + 1) >>> 0 // log(58) / log(256), rounded up.\n    var b256 = new Uint8Array(size)\n        // Process the characters.\n    while (source[psz]) {\n            // Find code of next character\n      var charCode = source.charCodeAt(psz)\n            // Base map can not be indexed using char code\n      if (charCode > 255) { return }\n            // Decode character\n      var carry = BASE_MAP[charCode]\n            // Invalid character\n      if (carry === 255) { return }\n      var i = 0\n      for (var it3 = size - 1; (carry !== 0 || i < length) && (it3 !== -1); it3--, i++) {\n        carry += (BASE * b256[it3]) >>> 0\n        b256[it3] = (carry % 256) >>> 0\n        carry = (carry / 256) >>> 0\n      }\n      if (carry !== 0) { throw new Error('Non-zero carry') }\n      length = i\n      psz++\n    }\n        // Skip leading zeroes in b256.\n    var it4 = size - length\n    while (it4 !== size && b256[it4] === 0) {\n      it4++\n    }\n    var vch = new Uint8Array(zeroes + (size - it4))\n    var j = zeroes\n    while (it4 !== size) {\n      vch[j++] = b256[it4++]\n    }\n    return vch\n  }\n  function decode (string) {\n    var buffer = decodeUnsafe(string)\n    if (buffer) { return buffer }\n    throw new Error('Non-base' + BASE + ' character')\n  }\n  return {\n    encode: encode,\n    decodeUnsafe: decodeUnsafe,\n    decode: decode\n  }\n}\nmodule.exports = base\n", "const basex = require('base-x')\nconst ALPHABET = '123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz'\n\nmodule.exports = basex(ALPHABET)\n", "'use strict'\n\nvar base58 = require('bs58')\n\nmodule.exports = function (checksumFn) {\n  // Encode a buffer as a base58-check encoded string\n  function encode (payload) {\n    var payloadU8 = Uint8Array.from(payload)\n    var checksum = checksumFn(payloadU8)\n    var length = payloadU8.length + 4\n    var both = new Uint8Array(length)\n    both.set(payloadU8, 0)\n    both.set(checksum.subarray(0, 4), payloadU8.length)\n    return base58.encode(both, length)\n  }\n\n  function decodeRaw (buffer) {\n    var payload = buffer.slice(0, -4)\n    var checksum = buffer.slice(-4)\n    var newChecksum = checksumFn(payload)\n\n    if (checksum[0] ^ newChecksum[0] |\n        checksum[1] ^ newChecksum[1] |\n        checksum[2] ^ newChecksum[2] |\n        checksum[3] ^ newChecksum[3]) return\n\n    return payload\n  }\n\n  // Decode a base58-check encoded string to a buffer, no result if checksum is wrong\n  function decodeUnsafe (string) {\n    var buffer = base58.decodeUnsafe(string)\n    if (!buffer) return\n\n    return decodeRaw(buffer)\n  }\n\n  function decode (string) {\n    var buffer = base58.decode(string)\n    var payload = decodeRaw(buffer, checksumFn)\n    if (!payload) throw new Error('Invalid checksum')\n    return payload\n  }\n\n  return {\n    encode: encode,\n    decode: decode,\n    decodeUnsafe: decodeUnsafe\n  }\n}\n", "'use strict'\n\nvar { sha256 } = require('@noble/hashes/sha256')\nvar bs58checkBase = require('./base')\n\n// SHA256(SHA256(buffer))\nfunction sha256x2 (buffer) {\n  return sha256(sha256(buffer))\n}\n\nmodule.exports = bs58checkBase(sha256x2)\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2pkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: {signature} {pubkey}\n// output: OP_DUP OP_HASH160 {hash160(pubkey)} OP_EQUALVERIFY OP_CHECKSIG\n/**\n * Creates a Pay-to-Public-Key-Hash (P2PKH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2PKH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2pkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(25)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2pkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(network.pubKeyHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(3, 23);\n    if (a.address) return _address().hash;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([\n      OPS.OP_DUP,\n      OPS.OP_HASH160,\n      o.hash,\n      OPS.OP_EQUALVERIFY,\n      OPS.OP_CHECKSIG,\n    ]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (!a.input) return;\n    return _chunks()[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.input) return;\n    return _chunks()[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return bscript.compile([a.signature, a.pubkey]);\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!o.input) return;\n    return [];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.pubKeyHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 25 ||\n        a.output[0] !== OPS.OP_DUP ||\n        a.output[1] !== OPS.OP_HASH160 ||\n        a.output[2] !== 0x14 ||\n        a.output[23] !== OPS.OP_EQUALVERIFY ||\n        a.output[24] !== OPS.OP_CHECKSIG\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(3, 23);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n    }\n    if (a.input) {\n      const chunks = _chunks();\n      if (chunks.length !== 2) throw new TypeError('Input is invalid');\n      if (!bscript.isCanonicalScriptSignature(chunks[0]))\n        throw new TypeError('Input has invalid signature');\n      if (!(0, types_1.isPoint)(chunks[1]))\n        throw new TypeError('Input has invalid pubkey');\n      if (a.signature && !a.signature.equals(chunks[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(chunks[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(chunks[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2pkh = p2pkh;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2sh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bs58check = require('bs58check');\nconst OPS = bscript.OPS;\n// input: [redeemScriptSig ...] {redeemScript}\n// witness: <?>\n// output: OP_HASH160 {hash160(redeemScript)} OP_EQUAL\n/**\n * Creates a Pay-to-Script-Hash (P2SH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2SH payment object.\n * @throws {TypeError} If the required data is not provided or if the data is invalid.\n */\nfunction p2sh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.input)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(23)),\n      redeem: types_1.typeforce.maybe({\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  const _address = lazy.value(() => {\n    const payload = Buffer.from(bs58check.decode(a.address));\n    const version = payload.readUInt8(0);\n    const hash = payload.slice(1);\n    return { version, hash };\n  });\n  const _chunks = lazy.value(() => {\n    return bscript.decompile(a.input);\n  });\n  const _redeem = lazy.value(() => {\n    const chunks = _chunks();\n    const lastChunk = chunks[chunks.length - 1];\n    return {\n      network,\n      output: lastChunk === OPS.OP_FALSE ? Buffer.from([]) : lastChunk,\n      input: bscript.compile(chunks.slice(0, -1)),\n      witness: a.witness || [],\n    };\n  });\n  // output dependents\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const payload = Buffer.allocUnsafe(21);\n    payload.writeUInt8(o.network.scriptHash, 0);\n    o.hash.copy(payload, 1);\n    return bs58check.encode(payload);\n  });\n  lazy.prop(o, 'hash', () => {\n    // in order of least effort\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().hash;\n    if (o.redeem && o.redeem.output) return bcrypto.hash160(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_HASH160, o.hash, OPS.OP_EQUAL]);\n  });\n  // input dependents\n  lazy.prop(o, 'redeem', () => {\n    if (!a.input) return;\n    return _redeem();\n  });\n  lazy.prop(o, 'input', () => {\n    if (!a.redeem || !a.redeem.input || !a.redeem.output) return;\n    return bscript.compile(\n      [].concat(bscript.decompile(a.redeem.input), a.redeem.output),\n    );\n  });\n  lazy.prop(o, 'witness', () => {\n    if (o.redeem && o.redeem.witness) return o.redeem.witness;\n    if (o.input) return [];\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2sh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().version !== network.scriptHash)\n        throw new TypeError('Invalid version or Network mismatch');\n      if (_address().hash.length !== 20) throw new TypeError('Invalid address');\n      hash = _address().hash;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 23 ||\n        a.output[0] !== OPS.OP_HASH160 ||\n        a.output[1] !== 0x14 ||\n        a.output[22] !== OPS.OP_EQUAL\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2, 22);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    // inlined to prevent 'no-inner-declarations' failing\n    const checkRedeem = redeem => {\n      // is the redeem output empty/invalid?\n      if (redeem.output) {\n        const decompile = bscript.decompile(redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output too short');\n        if (redeem.output.byteLength > 520)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 520 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.hash160(redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (redeem.input) {\n        const hasInput = redeem.input.length > 0;\n        const hasWitness = redeem.witness && redeem.witness.length > 0;\n        if (!hasInput && !hasWitness) throw new TypeError('Empty input');\n        if (hasInput && hasWitness)\n          throw new TypeError('Input and witness provided');\n        if (hasInput) {\n          const richunks = bscript.decompile(redeem.input);\n          if (!bscript.isPushOnly(richunks))\n            throw new TypeError('Non push-only scriptSig');\n        }\n      }\n    };\n    if (a.input) {\n      const chunks = _chunks();\n      if (!chunks || chunks.length < 1) throw new TypeError('Input too short');\n      if (!Buffer.isBuffer(_redeem().output))\n        throw new TypeError('Input is invalid');\n      checkRedeem(_redeem());\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      if (a.input) {\n        const redeem = _redeem();\n        if (a.redeem.output && !a.redeem.output.equals(redeem.output))\n          throw new TypeError('Redeem.output mismatch');\n        if (a.redeem.input && !a.redeem.input.equals(redeem.input))\n          throw new TypeError('Redeem.input mismatch');\n      }\n      checkRedeem(a.redeem);\n    }\n    if (a.witness) {\n      if (\n        a.redeem &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.redeem.witness, a.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2sh = p2sh;\n", "'use strict';\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.bech32m = exports.bech32 = void 0;\nconst ALPHABET = 'qpzry9x8gf2tvdw0s3jn54khce6mua7l';\nconst ALPHABET_MAP = {};\nfor (let z = 0; z < ALPHABET.length; z++) {\n    const x = ALPHABET.charAt(z);\n    ALPHABET_MAP[x] = z;\n}\nfunction polymodStep(pre) {\n    const b = pre >> 25;\n    return (((pre & 0x1ffffff) << 5) ^\n        (-((b >> 0) & 1) & 0x3b6a57b2) ^\n        (-((b >> 1) & 1) & 0x26508e6d) ^\n        (-((b >> 2) & 1) & 0x1ea119fa) ^\n        (-((b >> 3) & 1) & 0x3d4233dd) ^\n        (-((b >> 4) & 1) & 0x2a1462b3));\n}\nfunction prefixChk(prefix) {\n    let chk = 1;\n    for (let i = 0; i < prefix.length; ++i) {\n        const c = prefix.charCodeAt(i);\n        if (c < 33 || c > 126)\n            return 'Invalid prefix (' + prefix + ')';\n        chk = polymodStep(chk) ^ (c >> 5);\n    }\n    chk = polymodStep(chk);\n    for (let i = 0; i < prefix.length; ++i) {\n        const v = prefix.charCodeAt(i);\n        chk = polymodStep(chk) ^ (v & 0x1f);\n    }\n    return chk;\n}\nfunction convert(data, inBits, outBits, pad) {\n    let value = 0;\n    let bits = 0;\n    const maxV = (1 << outBits) - 1;\n    const result = [];\n    for (let i = 0; i < data.length; ++i) {\n        value = (value << inBits) | data[i];\n        bits += inBits;\n        while (bits >= outBits) {\n            bits -= outBits;\n            result.push((value >> bits) & maxV);\n        }\n    }\n    if (pad) {\n        if (bits > 0) {\n            result.push((value << (outBits - bits)) & maxV);\n        }\n    }\n    else {\n        if (bits >= inBits)\n            return 'Excess padding';\n        if ((value << (outBits - bits)) & maxV)\n            return 'Non-zero padding';\n    }\n    return result;\n}\nfunction toWords(bytes) {\n    return convert(bytes, 8, 5, true);\n}\nfunction fromWordsUnsafe(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n}\nfunction fromWords(words) {\n    const res = convert(words, 5, 8, false);\n    if (Array.isArray(res))\n        return res;\n    throw new Error(res);\n}\nfunction getLibraryFromEncoding(encoding) {\n    let ENCODING_CONST;\n    if (encoding === 'bech32') {\n        ENCODING_CONST = 1;\n    }\n    else {\n        ENCODING_CONST = 0x2bc830a3;\n    }\n    function encode(prefix, words, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (prefix.length + 7 + words.length > LIMIT)\n            throw new TypeError('Exceeds length limit');\n        prefix = prefix.toLowerCase();\n        // determine chk mod\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            throw new Error(chk);\n        let result = prefix + '1';\n        for (let i = 0; i < words.length; ++i) {\n            const x = words[i];\n            if (x >> 5 !== 0)\n                throw new Error('Non 5-bit word');\n            chk = polymodStep(chk) ^ x;\n            result += ALPHABET.charAt(x);\n        }\n        for (let i = 0; i < 6; ++i) {\n            chk = polymodStep(chk);\n        }\n        chk ^= ENCODING_CONST;\n        for (let i = 0; i < 6; ++i) {\n            const v = (chk >> ((5 - i) * 5)) & 0x1f;\n            result += ALPHABET.charAt(v);\n        }\n        return result;\n    }\n    function __decode(str, LIMIT) {\n        LIMIT = LIMIT || 90;\n        if (str.length < 8)\n            return str + ' too short';\n        if (str.length > LIMIT)\n            return 'Exceeds length limit';\n        // don't allow mixed case\n        const lowered = str.toLowerCase();\n        const uppered = str.toUpperCase();\n        if (str !== lowered && str !== uppered)\n            return 'Mixed-case string ' + str;\n        str = lowered;\n        const split = str.lastIndexOf('1');\n        if (split === -1)\n            return 'No separator character for ' + str;\n        if (split === 0)\n            return 'Missing prefix for ' + str;\n        const prefix = str.slice(0, split);\n        const wordChars = str.slice(split + 1);\n        if (wordChars.length < 6)\n            return 'Data too short';\n        let chk = prefixChk(prefix);\n        if (typeof chk === 'string')\n            return chk;\n        const words = [];\n        for (let i = 0; i < wordChars.length; ++i) {\n            const c = wordChars.charAt(i);\n            const v = ALPHABET_MAP[c];\n            if (v === undefined)\n                return 'Unknown character ' + c;\n            chk = polymodStep(chk) ^ v;\n            // not in the checksum?\n            if (i + 6 >= wordChars.length)\n                continue;\n            words.push(v);\n        }\n        if (chk !== ENCODING_CONST)\n            return 'Invalid checksum for ' + str;\n        return { prefix, words };\n    }\n    function decodeUnsafe(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n    }\n    function decode(str, LIMIT) {\n        const res = __decode(str, LIMIT);\n        if (typeof res === 'object')\n            return res;\n        throw new Error(res);\n    }\n    return {\n        decodeUnsafe,\n        decode,\n        encode,\n        toWords,\n        fromWordsUnsafe,\n        fromWords,\n    };\n}\nexports.bech32 = getLibraryFromEncoding('bech32');\nexports.bech32m = getLibraryFromEncoding('bech32m');\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wpkh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\n// witness: {signature} {pubKey}\n// input: <>\n// output: OP_0 {pubKeyHash}\n/**\n * Creates a pay-to-witness-public-key-hash (p2wpkh) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The p2wpkh payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wpkh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.pubkey && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(20)),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(22)),\n      pubkey: types_1.typeforce.maybe(types_1.isPoint),\n      signature: types_1.typeforce.maybe(bscript.isCanonicalScriptSignature),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2wpkh', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2, 22);\n    if (a.address) return _address().data;\n    if (a.pubkey || o.pubkey) return bcrypto.hash160(a.pubkey || o.pubkey);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (!a.witness) return;\n    return a.witness[1];\n  });\n  lazy.prop(o, 'signature', () => {\n    if (!a.witness) return;\n    return a.witness[0];\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    if (!a.pubkey) return;\n    if (!a.signature) return;\n    return [a.signature, a.pubkey];\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 20)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 22 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x14\n      )\n        throw new TypeError('Output is invalid');\n      if (hash.length > 0 && !hash.equals(a.output.slice(2)))\n        throw new TypeError('Hash mismatch');\n      else hash = a.output.slice(2);\n    }\n    if (a.pubkey) {\n      const pkh = bcrypto.hash160(a.pubkey);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n      else hash = pkh;\n      if (!(0, types_1.isPoint)(a.pubkey) || a.pubkey.length !== 33)\n        throw new TypeError('Invalid pubkey for p2wpkh');\n    }\n    if (a.witness) {\n      if (a.witness.length !== 2) throw new TypeError('Witness is invalid');\n      if (!bscript.isCanonicalScriptSignature(a.witness[0]))\n        throw new TypeError('Witness has invalid signature');\n      if (!(0, types_1.isPoint)(a.witness[1]) || a.witness[1].length !== 33)\n        throw new TypeError('Witness has invalid pubkey');\n      if (a.signature && !a.signature.equals(a.witness[0]))\n        throw new TypeError('Signature mismatch');\n      if (a.pubkey && !a.pubkey.equals(a.witness[1]))\n        throw new TypeError('Pubkey mismatch');\n      const pkh = bcrypto.hash160(a.witness[1]);\n      if (hash.length > 0 && !hash.equals(pkh))\n        throw new TypeError('Hash mismatch');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wpkh = p2wpkh;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2wsh = void 0;\nconst bcrypto = require('../crypto');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst OPS = bscript.OPS;\nconst EMPTY_BUFFER = Buffer.alloc(0);\nfunction chunkHasUncompressedPubkey(chunk) {\n  if (\n    Buffer.isBuffer(chunk) &&\n    chunk.length === 65 &&\n    chunk[0] === 0x04 &&\n    (0, types_1.isPoint)(chunk)\n  ) {\n    return true;\n  } else {\n    return false;\n  }\n}\n// input: <>\n// witness: [redeemScriptSig ...] {redeemScript}\n// output: OP_0 {sha256(redeemScript)}\n/**\n * Creates a Pay-to-Witness-Script-Hash (P2WSH) payment object.\n *\n * @param a - The payment object containing the necessary data.\n * @param opts - Optional payment options.\n * @returns The P2WSH payment object.\n * @throws {TypeError} If the required data is missing or invalid.\n */\nfunction p2wsh(a, opts) {\n  if (!a.address && !a.hash && !a.output && !a.redeem && !a.witness)\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      redeem: types_1.typeforce.maybe({\n        input: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        network: types_1.typeforce.maybe(types_1.typeforce.Object),\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    const result = bech32_1.bech32.decode(a.address);\n    const version = result.words.shift();\n    const data = bech32_1.bech32.fromWords(result.words);\n    return {\n      version,\n      prefix: result.prefix,\n      data: Buffer.from(data),\n    };\n  });\n  const _rchunks = lazy.value(() => {\n    return bscript.decompile(a.redeem.input);\n  });\n  let network = a.network;\n  if (!network) {\n    network = (a.redeem && a.redeem.network) || networks_1.bitcoin;\n  }\n  const o = { network };\n  lazy.prop(o, 'address', () => {\n    if (!o.hash) return;\n    const words = bech32_1.bech32.toWords(o.hash);\n    words.unshift(0x00);\n    return bech32_1.bech32.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.redeem && o.redeem.output) return bcrypto.sha256(o.redeem.output);\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.hash) return;\n    return bscript.compile([OPS.OP_0, o.hash]);\n  });\n  lazy.prop(o, 'redeem', () => {\n    if (!a.witness) return;\n    return {\n      output: a.witness[a.witness.length - 1],\n      input: EMPTY_BUFFER,\n      witness: a.witness.slice(0, -1),\n    };\n  });\n  lazy.prop(o, 'input', () => {\n    if (!o.witness) return;\n    return EMPTY_BUFFER;\n  });\n  lazy.prop(o, 'witness', () => {\n    // transform redeem input to witness stack?\n    if (\n      a.redeem &&\n      a.redeem.input &&\n      a.redeem.input.length > 0 &&\n      a.redeem.output &&\n      a.redeem.output.length > 0\n    ) {\n      const stack = bscript.toStack(_rchunks());\n      // assign, and blank the existing input\n      o.redeem = Object.assign({ witness: stack }, a.redeem);\n      o.redeem.input = EMPTY_BUFFER;\n      return [].concat(stack, a.redeem.output);\n    }\n    if (!a.redeem) return;\n    if (!a.redeem.output) return;\n    if (!a.redeem.witness) return;\n    return [].concat(a.redeem.witness, a.redeem.output);\n  });\n  lazy.prop(o, 'name', () => {\n    const nameParts = ['p2wsh'];\n    if (o.redeem !== undefined && o.redeem.name !== undefined)\n      nameParts.push(o.redeem.name);\n    return nameParts.join('-');\n  });\n  // extended validation\n  if (opts.validate) {\n    let hash = Buffer.from([]);\n    if (a.address) {\n      if (_address().prefix !== network.bech32)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== 0x00)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      hash = _address().data;\n    }\n    if (a.hash) {\n      if (hash.length > 0 && !hash.equals(a.hash))\n        throw new TypeError('Hash mismatch');\n      else hash = a.hash;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_0 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      const hash2 = a.output.slice(2);\n      if (hash.length > 0 && !hash.equals(hash2))\n        throw new TypeError('Hash mismatch');\n      else hash = hash2;\n    }\n    if (a.redeem) {\n      if (a.redeem.network && a.redeem.network !== network)\n        throw new TypeError('Network mismatch');\n      // is there two redeem sources?\n      if (\n        a.redeem.input &&\n        a.redeem.input.length > 0 &&\n        a.redeem.witness &&\n        a.redeem.witness.length > 0\n      )\n        throw new TypeError('Ambiguous witness source');\n      // is the redeem output non-empty/valid?\n      if (a.redeem.output) {\n        const decompile = bscript.decompile(a.redeem.output);\n        if (!decompile || decompile.length < 1)\n          throw new TypeError('Redeem.output is invalid');\n        if (a.redeem.output.byteLength > 3600)\n          throw new TypeError(\n            'Redeem.output unspendable if larger than 3600 bytes',\n          );\n        if (bscript.countNonPushOnlyOPs(decompile) > 201)\n          throw new TypeError(\n            'Redeem.output unspendable with more than 201 non-push ops',\n          );\n        // match hash against other sources\n        const hash2 = bcrypto.sha256(a.redeem.output);\n        if (hash.length > 0 && !hash.equals(hash2))\n          throw new TypeError('Hash mismatch');\n        else hash = hash2;\n      }\n      if (a.redeem.input && !bscript.isPushOnly(_rchunks()))\n        throw new TypeError('Non push-only scriptSig');\n      if (\n        a.witness &&\n        a.redeem.witness &&\n        !(0, types_1.stacksEqual)(a.witness, a.redeem.witness)\n      )\n        throw new TypeError('Witness and redeem.witness mismatch');\n      if (\n        (a.redeem.input && _rchunks().some(chunkHasUncompressedPubkey)) ||\n        (a.redeem.output &&\n          (bscript.decompile(a.redeem.output) || []).some(\n            chunkHasUncompressedPubkey,\n          ))\n      ) {\n        throw new TypeError(\n          'redeem.input or redeem.output contains uncompressed pubkey',\n        );\n      }\n    }\n    if (a.witness && a.witness.length > 0) {\n      const wScript = a.witness[a.witness.length - 1];\n      if (a.redeem && a.redeem.output && !a.redeem.output.equals(wScript))\n        throw new TypeError('Witness and redeem.output mismatch');\n      if (\n        a.witness.some(chunkHasUncompressedPubkey) ||\n        (bscript.decompile(wScript) || []).some(chunkHasUncompressedPubkey)\n      )\n        throw new TypeError('Witness contains uncompressed pubkey');\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2wsh = p2wsh;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.getEccLib = exports.initEccLib = void 0;\nconst _ECCLIB_CACHE = {};\n/**\n * Initializes the ECC library with the provided instance.\n * If `eccLib` is `undefined`, the library will be cleared.\n * If `eccLib` is a new instance, it will be verified before setting it as the active library.\n *\n * @param eccLib The instance of the ECC library to initialize.\n * @param opts Extra initialization options. Use {DANGER_DO_NOT_VERIFY_ECCLIB:true} if ecc verification should not be executed. Not recommended!\n */\nfunction initEccLib(eccLib, opts) {\n  if (!eccLib) {\n    // allow clearing the library\n    _ECCLIB_CACHE.eccLib = eccLib;\n  } else if (eccLib !== _ECCLIB_CACHE.eccLib) {\n    if (!opts?.DANGER_DO_NOT_VERIFY_ECCLIB)\n      // new instance, verify it\n      verifyEcc(eccLib);\n    _ECCLIB_CACHE.eccLib = eccLib;\n  }\n}\nexports.initEccLib = initEccLib;\n/**\n * Retrieves the ECC Library instance.\n * Throws an error if the ECC Library is not provided.\n * You must call initEccLib() with a valid TinySecp256k1Interface instance before calling this function.\n * @returns The ECC Library instance.\n * @throws Error if the ECC Library is not provided.\n */\nfunction getEccLib() {\n  if (!_ECCLIB_CACHE.eccLib)\n    throw new Error(\n      'No ECC Library provided. You must call initEccLib() with a valid TinySecp256k1Interface instance',\n    );\n  return _ECCLIB_CACHE.eccLib;\n}\nexports.getEccLib = getEccLib;\nconst h = hex => Buffer.from(hex, 'hex');\n/**\n * Verifies the ECC functionality.\n *\n * @param ecc - The TinySecp256k1Interface object.\n */\nfunction verifyEcc(ecc) {\n  assert(typeof ecc.isXOnlyPoint === 'function');\n  assert(\n    ecc.isXOnlyPoint(\n      h('79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffeeffffc2e'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('f9308a019258c31049344f85f89d5229b531c845836f99b08601f113bce036f9'),\n    ),\n  );\n  assert(\n    ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000001'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('0000000000000000000000000000000000000000000000000000000000000000'),\n    ),\n  );\n  assert(\n    !ecc.isXOnlyPoint(\n      h('fffffffffffffffffffffffffffffffffffffffffffffffffffffffefffffc2f'),\n    ),\n  );\n  assert(typeof ecc.xOnlyPointAddTweak === 'function');\n  tweakAddVectors.forEach(t => {\n    const r = ecc.xOnlyPointAddTweak(h(t.pubkey), h(t.tweak));\n    if (t.result === null) {\n      assert(r === null);\n    } else {\n      assert(r !== null);\n      assert(r.parity === t.parity);\n      assert(Buffer.from(r.xOnlyPubkey).equals(h(t.result)));\n    }\n  });\n}\nfunction assert(bool) {\n  if (!bool) throw new Error('ecc library invalid');\n}\nconst tweakAddVectors = [\n  {\n    pubkey: '79be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798',\n    tweak: 'fffffffffffffffffffffffffffffffebaaedce6af48a03bbfd25e8cd0364140',\n    parity: -1,\n    result: null,\n  },\n  {\n    pubkey: '1617d38ed8d8657da4d4761e8057bc396ea9e4b9d29776d4be096016dbd2509b',\n    tweak: 'a8397a935f0dfceba6ba9618f6451ef4d80637abf4e6af2669fbc9de6a8fd2ac',\n    parity: 1,\n    result: 'e478f99dab91052ab39a33ea35fd5e6e4933f4d28023cd597c9a1f6760346adf',\n  },\n  {\n    pubkey: '2c0b7cf95324a07d05398b240174dc0c2be444d96b159aa6c7f7b1e668680991',\n    tweak: '823c3cd2142744b075a87eade7e1b8678ba308d566226a0056ca2b7a76f86b47',\n    parity: 0,\n    result: '9534f8dc8c6deda2dc007655981c78b49c5d96c778fbf363462a11ec9dfd948c',\n  },\n];\n", "'use strict'\nvar Buffer = require('safe-buffer').Buffer\n\n// Number.MAX_SAFE_INTEGER\nvar MAX_SAFE_INTEGER = 9007199254740991\n\nfunction checkUInt53 (n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0) throw new RangeError('value out of range')\n}\n\nfunction encode (number, buffer, offset) {\n  checkUInt53(number)\n\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(number))\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  // 8 bit\n  if (number < 0xfd) {\n    buffer.writeUInt8(number, offset)\n    encode.bytes = 1\n\n  // 16 bit\n  } else if (number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset)\n    buffer.writeUInt16LE(number, offset + 1)\n    encode.bytes = 3\n\n  // 32 bit\n  } else if (number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset)\n    buffer.writeUInt32LE(number, offset + 1)\n    encode.bytes = 5\n\n  // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset)\n    buffer.writeUInt32LE(number >>> 0, offset + 1)\n    buffer.writeUInt32LE((number / 0x100000000) | 0, offset + 5)\n    encode.bytes = 9\n  }\n\n  return buffer\n}\n\nfunction decode (buffer, offset) {\n  if (!Buffer.isBuffer(buffer)) throw new TypeError('buffer must be a Buffer instance')\n  if (!offset) offset = 0\n\n  var first = buffer.readUInt8(offset)\n\n  // 8 bit\n  if (first < 0xfd) {\n    decode.bytes = 1\n    return first\n\n  // 16 bit\n  } else if (first === 0xfd) {\n    decode.bytes = 3\n    return buffer.readUInt16LE(offset + 1)\n\n  // 32 bit\n  } else if (first === 0xfe) {\n    decode.bytes = 5\n    return buffer.readUInt32LE(offset + 1)\n\n  // 64 bit\n  } else {\n    decode.bytes = 9\n    var lo = buffer.readUInt32LE(offset + 1)\n    var hi = buffer.readUInt32LE(offset + 5)\n    var number = hi * 0x0100000000 + lo\n    checkUInt53(number)\n\n    return number\n  }\n}\n\nfunction encodingLength (number) {\n  checkUInt53(number)\n\n  return (\n    number < 0xfd ? 1\n      : number <= 0xffff ? 3\n        : number <= 0xffffffff ? 5\n          : 9\n  )\n}\n\nmodule.exports = { encode: encode, decode: decode, encodingLength: encodingLength }\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.BufferReader =\n  exports.BufferWriter =\n  exports.cloneBuffer =\n  exports.reverseBuffer =\n  exports.writeUInt64LE =\n  exports.readUInt64LE =\n  exports.varuint =\n    void 0;\nconst types = require('./types');\nconst { typeforce } = types;\nconst varuint = require('varuint-bitcoin');\nexports.varuint = varuint;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\n/**\n * Writes a 64-bit unsigned integer in little-endian format to the specified buffer at the given offset.\n *\n * @param buffer - The buffer to write the value to.\n * @param value - The 64-bit unsigned integer value to write.\n * @param offset - The offset in the buffer where the value should be written.\n * @returns The new offset after writing the value.\n */\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n/**\n * Reverses the order of bytes in a buffer.\n * @param buffer - The buffer to reverse.\n * @returns A new buffer with the bytes reversed.\n */\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction cloneBuffer(buffer) {\n  const clone = Buffer.allocUnsafe(buffer.length);\n  buffer.copy(clone);\n  return clone;\n}\nexports.cloneBuffer = cloneBuffer;\n/**\n * Helper class for serialization of bitcoin data types into a pre-allocated buffer.\n */\nclass BufferWriter {\n  static withCapacity(size) {\n    return new BufferWriter(Buffer.alloc(size));\n  }\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  writeUInt8(i) {\n    this.offset = this.buffer.writeUInt8(i, this.offset);\n  }\n  writeInt32(i) {\n    this.offset = this.buffer.writeInt32LE(i, this.offset);\n  }\n  writeUInt32(i) {\n    this.offset = this.buffer.writeUInt32LE(i, this.offset);\n  }\n  writeUInt64(i) {\n    this.offset = writeUInt64LE(this.buffer, i, this.offset);\n  }\n  writeVarInt(i) {\n    varuint.encode(i, this.buffer, this.offset);\n    this.offset += varuint.encode.bytes;\n  }\n  writeSlice(slice) {\n    if (this.buffer.length < this.offset + slice.length) {\n      throw new Error('Cannot write slice out of bounds');\n    }\n    this.offset += slice.copy(this.buffer, this.offset);\n  }\n  writeVarSlice(slice) {\n    this.writeVarInt(slice.length);\n    this.writeSlice(slice);\n  }\n  writeVector(vector) {\n    this.writeVarInt(vector.length);\n    vector.forEach(buf => this.writeVarSlice(buf));\n  }\n  end() {\n    if (this.buffer.length === this.offset) {\n      return this.buffer;\n    }\n    throw new Error(`buffer size ${this.buffer.length}, offset ${this.offset}`);\n  }\n}\nexports.BufferWriter = BufferWriter;\n/**\n * Helper class for reading of bitcoin data types from a buffer.\n */\nclass BufferReader {\n  constructor(buffer, offset = 0) {\n    this.buffer = buffer;\n    this.offset = offset;\n    typeforce(types.tuple(types.Buffer, types.UInt32), [buffer, offset]);\n  }\n  readUInt8() {\n    const result = this.buffer.readUInt8(this.offset);\n    this.offset++;\n    return result;\n  }\n  readInt32() {\n    const result = this.buffer.readInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt32() {\n    const result = this.buffer.readUInt32LE(this.offset);\n    this.offset += 4;\n    return result;\n  }\n  readUInt64() {\n    const result = readUInt64LE(this.buffer, this.offset);\n    this.offset += 8;\n    return result;\n  }\n  readVarInt() {\n    const vi = varuint.decode(this.buffer, this.offset);\n    this.offset += varuint.decode.bytes;\n    return vi;\n  }\n  readSlice(n) {\n    if (this.buffer.length < this.offset + n) {\n      throw new Error('Cannot read slice out of bounds');\n    }\n    const result = this.buffer.slice(this.offset, this.offset + n);\n    this.offset += n;\n    return result;\n  }\n  readVarSlice() {\n    return this.readSlice(this.readVarInt());\n  }\n  readVector() {\n    const count = this.readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(this.readVarSlice());\n    return vector;\n  }\n}\nexports.BufferReader = BufferReader;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.tweakKey =\n  exports.tapTweakHash =\n  exports.tapleafHash =\n  exports.findScriptPath =\n  exports.toHashTree =\n  exports.rootHashFromPath =\n  exports.MAX_TAPTREE_DEPTH =\n  exports.LEAF_VERSION_TAPSCRIPT =\n    void 0;\nconst buffer_1 = require('buffer');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bcrypto = require('../crypto');\nconst bufferutils_1 = require('../bufferutils');\nconst types_1 = require('../types');\nexports.LEAF_VERSION_TAPSCRIPT = 0xc0;\nexports.MAX_TAPTREE_DEPTH = 128;\nconst isHashBranch = ht => 'left' in ht && 'right' in ht;\n/**\n * Calculates the root hash from a given control block and leaf hash.\n * @param controlBlock - The control block buffer.\n * @param leafHash - The leaf hash buffer.\n * @returns The root hash buffer.\n * @throws {TypeError} If the control block length is less than 33.\n */\nfunction rootHashFromPath(controlBlock, leafHash) {\n  if (controlBlock.length < 33)\n    throw new TypeError(\n      `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n    );\n  const m = (controlBlock.length - 33) / 32;\n  let kj = leafHash;\n  for (let j = 0; j < m; j++) {\n    const ej = controlBlock.slice(33 + 32 * j, 65 + 32 * j);\n    if (kj.compare(ej) < 0) {\n      kj = tapBranchHash(kj, ej);\n    } else {\n      kj = tapBranchHash(ej, kj);\n    }\n  }\n  return kj;\n}\nexports.rootHashFromPath = rootHashFromPath;\n/**\n * Build a hash tree of merkle nodes from the scripts binary tree.\n * @param scriptTree - the tree of scripts to pairwise hash.\n */\nfunction toHashTree(scriptTree) {\n  if ((0, types_1.isTapleaf)(scriptTree))\n    return { hash: tapleafHash(scriptTree) };\n  const hashes = [toHashTree(scriptTree[0]), toHashTree(scriptTree[1])];\n  hashes.sort((a, b) => a.hash.compare(b.hash));\n  const [left, right] = hashes;\n  return {\n    hash: tapBranchHash(left.hash, right.hash),\n    left,\n    right,\n  };\n}\nexports.toHashTree = toHashTree;\n/**\n * Given a HashTree, finds the path from a particular hash to the root.\n * @param node - the root of the tree\n * @param hash - the hash to search for\n * @returns - array of sibling hashes, from leaf (inclusive) to root\n * (exclusive) needed to prove inclusion of the specified hash. undefined if no\n * path is found\n */\nfunction findScriptPath(node, hash) {\n  if (isHashBranch(node)) {\n    const leftPath = findScriptPath(node.left, hash);\n    if (leftPath !== undefined) return [...leftPath, node.right.hash];\n    const rightPath = findScriptPath(node.right, hash);\n    if (rightPath !== undefined) return [...rightPath, node.left.hash];\n  } else if (node.hash.equals(hash)) {\n    return [];\n  }\n  return undefined;\n}\nexports.findScriptPath = findScriptPath;\nfunction tapleafHash(leaf) {\n  const version = leaf.version || exports.LEAF_VERSION_TAPSCRIPT;\n  return bcrypto.taggedHash(\n    'TapLeaf',\n    buffer_1.Buffer.concat([\n      buffer_1.Buffer.from([version]),\n      serializeScript(leaf.output),\n    ]),\n  );\n}\nexports.tapleafHash = tapleafHash;\nfunction tapTweakHash(pubKey, h) {\n  return bcrypto.taggedHash(\n    'TapTweak',\n    buffer_1.Buffer.concat(h ? [pubKey, h] : [pubKey]),\n  );\n}\nexports.tapTweakHash = tapTweakHash;\nfunction tweakKey(pubKey, h) {\n  if (!buffer_1.Buffer.isBuffer(pubKey)) return null;\n  if (pubKey.length !== 32) return null;\n  if (h && h.length !== 32) return null;\n  const tweakHash = tapTweakHash(pubKey, h);\n  const res = (0, ecc_lib_1.getEccLib)().xOnlyPointAddTweak(pubKey, tweakHash);\n  if (!res || res.xOnlyPubkey === null) return null;\n  return {\n    parity: res.parity,\n    x: buffer_1.Buffer.from(res.xOnlyPubkey),\n  };\n}\nexports.tweakKey = tweakKey;\nfunction tapBranchHash(a, b) {\n  return bcrypto.taggedHash('TapBranch', buffer_1.Buffer.concat([a, b]));\n}\nfunction serializeScript(s) {\n  const varintLen = bufferutils_1.varuint.encodingLength(s.length);\n  const buffer = buffer_1.Buffer.allocUnsafe(varintLen); // better\n  bufferutils_1.varuint.encode(s.length, buffer);\n  return buffer_1.Buffer.concat([buffer, s]);\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr = void 0;\nconst buffer_1 = require('buffer');\nconst networks_1 = require('../networks');\nconst bscript = require('../script');\nconst types_1 = require('../types');\nconst ecc_lib_1 = require('../ecc_lib');\nconst bip341_1 = require('./bip341');\nconst lazy = require('./lazy');\nconst bech32_1 = require('bech32');\nconst address_1 = require('../address');\nconst OPS = bscript.OPS;\nconst TAPROOT_WITNESS_VERSION = 0x01;\nconst ANNEX_PREFIX = 0x50;\n/**\n * Creates a Pay-to-Taproot (P2TR) payment object.\n *\n * @param a - The payment object containing the necessary data for P2TR.\n * @param opts - Optional payment options.\n * @returns The P2TR payment object.\n * @throws {TypeError} If the provided data is invalid or insufficient.\n */\nfunction p2tr(a, opts) {\n  if (\n    !a.address &&\n    !a.output &&\n    !a.pubkey &&\n    !a.internalPubkey &&\n    !(a.witness && a.witness.length > 1)\n  )\n    throw new TypeError('Not enough data');\n  opts = Object.assign({ validate: true }, opts || {});\n  (0, types_1.typeforce)(\n    {\n      address: types_1.typeforce.maybe(types_1.typeforce.String),\n      input: types_1.typeforce.maybe(types_1.typeforce.BufferN(0)),\n      network: types_1.typeforce.maybe(types_1.typeforce.Object),\n      output: types_1.typeforce.maybe(types_1.typeforce.BufferN(34)),\n      internalPubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      hash: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      pubkey: types_1.typeforce.maybe(types_1.typeforce.BufferN(32)),\n      signature: types_1.typeforce.maybe(\n        types_1.typeforce.anyOf(\n          types_1.typeforce.BufferN(64),\n          types_1.typeforce.BufferN(65),\n        ),\n      ),\n      witness: types_1.typeforce.maybe(\n        types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n      ),\n      scriptTree: types_1.typeforce.maybe(types_1.isTaptree),\n      redeem: types_1.typeforce.maybe({\n        output: types_1.typeforce.maybe(types_1.typeforce.Buffer),\n        redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n        witness: types_1.typeforce.maybe(\n          types_1.typeforce.arrayOf(types_1.typeforce.Buffer),\n        ),\n      }),\n      redeemVersion: types_1.typeforce.maybe(types_1.typeforce.Number),\n    },\n    a,\n  );\n  const _address = lazy.value(() => {\n    return (0, address_1.fromBech32)(a.address);\n  });\n  // remove annex if present, ignored by taproot\n  const _witness = lazy.value(() => {\n    if (!a.witness || !a.witness.length) return;\n    if (\n      a.witness.length >= 2 &&\n      a.witness[a.witness.length - 1][0] === ANNEX_PREFIX\n    ) {\n      return a.witness.slice(0, -1);\n    }\n    return a.witness.slice();\n  });\n  const _hashTree = lazy.value(() => {\n    if (a.scriptTree) return (0, bip341_1.toHashTree)(a.scriptTree);\n    if (a.hash) return { hash: a.hash };\n    return;\n  });\n  const network = a.network || networks_1.bitcoin;\n  const o = { name: 'p2tr', network };\n  lazy.prop(o, 'address', () => {\n    if (!o.pubkey) return;\n    const words = bech32_1.bech32m.toWords(o.pubkey);\n    words.unshift(TAPROOT_WITNESS_VERSION);\n    return bech32_1.bech32m.encode(network.bech32, words);\n  });\n  lazy.prop(o, 'hash', () => {\n    const hashTree = _hashTree();\n    if (hashTree) return hashTree.hash;\n    const w = _witness();\n    if (w && w.length > 1) {\n      const controlBlock = w[w.length - 1];\n      const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n      const script = w[w.length - 2];\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: script,\n        version: leafVersion,\n      });\n      return (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n    }\n    return null;\n  });\n  lazy.prop(o, 'output', () => {\n    if (!o.pubkey) return;\n    return bscript.compile([OPS.OP_1, o.pubkey]);\n  });\n  lazy.prop(o, 'redeemVersion', () => {\n    if (a.redeemVersion) return a.redeemVersion;\n    if (\n      a.redeem &&\n      a.redeem.redeemVersion !== undefined &&\n      a.redeem.redeemVersion !== null\n    ) {\n      return a.redeem.redeemVersion;\n    }\n    return bip341_1.LEAF_VERSION_TAPSCRIPT;\n  });\n  lazy.prop(o, 'redeem', () => {\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length < 2) return;\n    return {\n      output: witness[witness.length - 2],\n      witness: witness.slice(0, -2),\n      redeemVersion:\n        witness[witness.length - 1][0] & types_1.TAPLEAF_VERSION_MASK,\n    };\n  });\n  lazy.prop(o, 'pubkey', () => {\n    if (a.pubkey) return a.pubkey;\n    if (a.output) return a.output.slice(2);\n    if (a.address) return _address().data;\n    if (o.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(o.internalPubkey, o.hash);\n      if (tweakedKey) return tweakedKey.x;\n    }\n  });\n  lazy.prop(o, 'internalPubkey', () => {\n    if (a.internalPubkey) return a.internalPubkey;\n    const witness = _witness();\n    if (witness && witness.length > 1)\n      return witness[witness.length - 1].slice(1, 33);\n  });\n  lazy.prop(o, 'signature', () => {\n    if (a.signature) return a.signature;\n    const witness = _witness(); // witness without annex\n    if (!witness || witness.length !== 1) return;\n    return witness[0];\n  });\n  lazy.prop(o, 'witness', () => {\n    if (a.witness) return a.witness;\n    const hashTree = _hashTree();\n    if (hashTree && a.redeem && a.redeem.output && a.internalPubkey) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      const path = (0, bip341_1.findScriptPath)(hashTree, leafHash);\n      if (!path) return;\n      const outputKey = (0, bip341_1.tweakKey)(a.internalPubkey, hashTree.hash);\n      if (!outputKey) return;\n      const controlBock = buffer_1.Buffer.concat(\n        [\n          buffer_1.Buffer.from([o.redeemVersion | outputKey.parity]),\n          a.internalPubkey,\n        ].concat(path),\n      );\n      return [a.redeem.output, controlBock];\n    }\n    if (a.signature) return [a.signature];\n  });\n  // extended validation\n  if (opts.validate) {\n    let pubkey = buffer_1.Buffer.from([]);\n    if (a.address) {\n      if (network && network.bech32 !== _address().prefix)\n        throw new TypeError('Invalid prefix or Network mismatch');\n      if (_address().version !== TAPROOT_WITNESS_VERSION)\n        throw new TypeError('Invalid address version');\n      if (_address().data.length !== 32)\n        throw new TypeError('Invalid address data');\n      pubkey = _address().data;\n    }\n    if (a.pubkey) {\n      if (pubkey.length > 0 && !pubkey.equals(a.pubkey))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.pubkey;\n    }\n    if (a.output) {\n      if (\n        a.output.length !== 34 ||\n        a.output[0] !== OPS.OP_1 ||\n        a.output[1] !== 0x20\n      )\n        throw new TypeError('Output is invalid');\n      if (pubkey.length > 0 && !pubkey.equals(a.output.slice(2)))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = a.output.slice(2);\n    }\n    if (a.internalPubkey) {\n      const tweakedKey = (0, bip341_1.tweakKey)(a.internalPubkey, o.hash);\n      if (pubkey.length > 0 && !pubkey.equals(tweakedKey.x))\n        throw new TypeError('Pubkey mismatch');\n      else pubkey = tweakedKey.x;\n    }\n    if (pubkey && pubkey.length) {\n      if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(pubkey))\n        throw new TypeError('Invalid pubkey for p2tr');\n    }\n    const hashTree = _hashTree();\n    if (a.hash && hashTree) {\n      if (!a.hash.equals(hashTree.hash)) throw new TypeError('Hash mismatch');\n    }\n    if (a.redeem && a.redeem.output && hashTree) {\n      const leafHash = (0, bip341_1.tapleafHash)({\n        output: a.redeem.output,\n        version: o.redeemVersion,\n      });\n      if (!(0, bip341_1.findScriptPath)(hashTree, leafHash))\n        throw new TypeError('Redeem script not in tree');\n    }\n    const witness = _witness();\n    // compare the provided redeem data with the one computed from witness\n    if (a.redeem && o.redeem) {\n      if (a.redeem.redeemVersion) {\n        if (a.redeem.redeemVersion !== o.redeem.redeemVersion)\n          throw new TypeError('Redeem.redeemVersion and witness mismatch');\n      }\n      if (a.redeem.output) {\n        if (bscript.decompile(a.redeem.output).length === 0)\n          throw new TypeError('Redeem.output is invalid');\n        // output redeem is constructed from the witness\n        if (o.redeem.output && !a.redeem.output.equals(o.redeem.output))\n          throw new TypeError('Redeem.output and witness mismatch');\n      }\n      if (a.redeem.witness) {\n        if (\n          o.redeem.witness &&\n          !(0, types_1.stacksEqual)(a.redeem.witness, o.redeem.witness)\n        )\n          throw new TypeError('Redeem.witness and witness mismatch');\n      }\n    }\n    if (witness && witness.length) {\n      if (witness.length === 1) {\n        // key spending\n        if (a.signature && !a.signature.equals(witness[0]))\n          throw new TypeError('Signature mismatch');\n      } else {\n        // script path spending\n        const controlBlock = witness[witness.length - 1];\n        if (controlBlock.length < 33)\n          throw new TypeError(\n            `The control-block length is too small. Got ${controlBlock.length}, expected min 33.`,\n          );\n        if ((controlBlock.length - 33) % 32 !== 0)\n          throw new TypeError(\n            `The control-block length of ${controlBlock.length} is incorrect!`,\n          );\n        const m = (controlBlock.length - 33) / 32;\n        if (m > 128)\n          throw new TypeError(\n            `The script path is too long. Got ${m}, expected max 128.`,\n          );\n        const internalPubkey = controlBlock.slice(1, 33);\n        if (a.internalPubkey && !a.internalPubkey.equals(internalPubkey))\n          throw new TypeError('Internal pubkey mismatch');\n        if (!(0, ecc_lib_1.getEccLib)().isXOnlyPoint(internalPubkey))\n          throw new TypeError('Invalid internalPubkey for p2tr witness');\n        const leafVersion = controlBlock[0] & types_1.TAPLEAF_VERSION_MASK;\n        const script = witness[witness.length - 2];\n        const leafHash = (0, bip341_1.tapleafHash)({\n          output: script,\n          version: leafVersion,\n        });\n        const hash = (0, bip341_1.rootHashFromPath)(controlBlock, leafHash);\n        const outputKey = (0, bip341_1.tweakKey)(internalPubkey, hash);\n        if (!outputKey)\n          // todo: needs test data\n          throw new TypeError('Invalid outputKey for p2tr witness');\n        if (pubkey.length && !pubkey.equals(outputKey.x))\n          throw new TypeError('Pubkey mismatch for p2tr witness');\n        if (outputKey.parity !== (controlBlock[0] & 1))\n          throw new Error('Incorrect parity');\n      }\n    }\n  }\n  return Object.assign(o, a);\n}\nexports.p2tr = p2tr;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.p2tr =\n  exports.p2wsh =\n  exports.p2wpkh =\n  exports.p2sh =\n  exports.p2pkh =\n  exports.p2pk =\n  exports.p2ms =\n  exports.embed =\n    void 0;\nconst embed_1 = require('./embed');\nObject.defineProperty(exports, 'embed', {\n  enumerable: true,\n  get: function () {\n    return embed_1.p2data;\n  },\n});\nconst p2ms_1 = require('./p2ms');\nObject.defineProperty(exports, 'p2ms', {\n  enumerable: true,\n  get: function () {\n    return p2ms_1.p2ms;\n  },\n});\nconst p2pk_1 = require('./p2pk');\nObject.defineProperty(exports, 'p2pk', {\n  enumerable: true,\n  get: function () {\n    return p2pk_1.p2pk;\n  },\n});\nconst p2pkh_1 = require('./p2pkh');\nObject.defineProperty(exports, 'p2pkh', {\n  enumerable: true,\n  get: function () {\n    return p2pkh_1.p2pkh;\n  },\n});\nconst p2sh_1 = require('./p2sh');\nObject.defineProperty(exports, 'p2sh', {\n  enumerable: true,\n  get: function () {\n    return p2sh_1.p2sh;\n  },\n});\nconst p2wpkh_1 = require('./p2wpkh');\nObject.defineProperty(exports, 'p2wpkh', {\n  enumerable: true,\n  get: function () {\n    return p2wpkh_1.p2wpkh;\n  },\n});\nconst p2wsh_1 = require('./p2wsh');\nObject.defineProperty(exports, 'p2wsh', {\n  enumerable: true,\n  get: function () {\n    return p2wsh_1.p2wsh;\n  },\n});\nconst p2tr_1 = require('./p2tr');\nObject.defineProperty(exports, 'p2tr', {\n  enumerable: true,\n  get: function () {\n    return p2tr_1.p2tr;\n  },\n});\n// TODO\n// witness commitment\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.toOutputScript =\n  exports.fromOutputScript =\n  exports.toBech32 =\n  exports.toBase58Check =\n  exports.fromBech32 =\n  exports.fromBase58Check =\n    void 0;\nconst networks = require('./networks');\nconst payments = require('./payments');\nconst bscript = require('./script');\nconst types_1 = require('./types');\nconst bech32_1 = require('bech32');\nconst bs58check = require('bs58check');\nconst FUTURE_SEGWIT_MAX_SIZE = 40;\nconst FUTURE_SEGWIT_MIN_SIZE = 2;\nconst FUTURE_SEGWIT_MAX_VERSION = 16;\nconst FUTURE_SEGWIT_MIN_VERSION = 2;\nconst FUTURE_SEGWIT_VERSION_DIFF = 0x50;\nconst FUTURE_SEGWIT_VERSION_WARNING =\n  'WARNING: Sending to a future segwit version address can lead to loss of funds. ' +\n  'End users MUST be warned carefully in the GUI and asked if they wish to proceed ' +\n  'with caution. Wallets should verify the segwit version from the output of fromBech32, ' +\n  'then decide when it is safe to use which version of segwit.';\nfunction _toFutureSegwitAddress(output, network) {\n  const data = output.slice(2);\n  if (\n    data.length < FUTURE_SEGWIT_MIN_SIZE ||\n    data.length > FUTURE_SEGWIT_MAX_SIZE\n  )\n    throw new TypeError('Invalid program length for segwit address');\n  const version = output[0] - FUTURE_SEGWIT_VERSION_DIFF;\n  if (\n    version < FUTURE_SEGWIT_MIN_VERSION ||\n    version > FUTURE_SEGWIT_MAX_VERSION\n  )\n    throw new TypeError('Invalid version for segwit address');\n  if (output[1] !== data.length)\n    throw new TypeError('Invalid script for segwit address');\n  console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n  return toBech32(data, version, network.bech32);\n}\n/**\n * decode address with base58 specification,  return address version and address hash if valid\n */\nfunction fromBase58Check(address) {\n  const payload = Buffer.from(bs58check.decode(address));\n  // TODO: 4.0.0, move to \"toOutputScript\"\n  if (payload.length < 21) throw new TypeError(address + ' is too short');\n  if (payload.length > 21) throw new TypeError(address + ' is too long');\n  const version = payload.readUInt8(0);\n  const hash = payload.slice(1);\n  return { version, hash };\n}\nexports.fromBase58Check = fromBase58Check;\n/**\n * decode address with bech32 specification,  return address version、address prefix and address data if valid\n */\nfunction fromBech32(address) {\n  let result;\n  let version;\n  try {\n    result = bech32_1.bech32.decode(address);\n  } catch (e) {}\n  if (result) {\n    version = result.words[0];\n    if (version !== 0) throw new TypeError(address + ' uses wrong encoding');\n  } else {\n    result = bech32_1.bech32m.decode(address);\n    version = result.words[0];\n    if (version === 0) throw new TypeError(address + ' uses wrong encoding');\n  }\n  const data = bech32_1.bech32.fromWords(result.words.slice(1));\n  return {\n    version,\n    prefix: result.prefix,\n    data: Buffer.from(data),\n  };\n}\nexports.fromBech32 = fromBech32;\n/**\n * encode address hash to base58 address with version\n */\nfunction toBase58Check(hash, version) {\n  (0, types_1.typeforce)(\n    (0, types_1.tuple)(types_1.Hash160bit, types_1.UInt8),\n    arguments,\n  );\n  const payload = Buffer.allocUnsafe(21);\n  payload.writeUInt8(version, 0);\n  hash.copy(payload, 1);\n  return bs58check.encode(payload);\n}\nexports.toBase58Check = toBase58Check;\n/**\n * encode address hash to bech32 address with version and prefix\n */\nfunction toBech32(data, version, prefix) {\n  const words = bech32_1.bech32.toWords(data);\n  words.unshift(version);\n  return version === 0\n    ? bech32_1.bech32.encode(prefix, words)\n    : bech32_1.bech32m.encode(prefix, words);\n}\nexports.toBech32 = toBech32;\n/**\n * decode address from output script with network, return address if matched\n */\nfunction fromOutputScript(output, network) {\n  // TODO: Network\n  network = network || networks.bitcoin;\n  try {\n    return payments.p2pkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2sh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wpkh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2wsh({ output, network }).address;\n  } catch (e) {}\n  try {\n    return payments.p2tr({ output, network }).address;\n  } catch (e) {}\n  try {\n    return _toFutureSegwitAddress(output, network);\n  } catch (e) {}\n  throw new Error(bscript.toASM(output) + ' has no matching Address');\n}\nexports.fromOutputScript = fromOutputScript;\n/**\n * encodes address to output script with network, return output script if address matched\n */\nfunction toOutputScript(address, network) {\n  network = network || networks.bitcoin;\n  let decodeBase58;\n  let decodeBech32;\n  try {\n    decodeBase58 = fromBase58Check(address);\n  } catch (e) {}\n  if (decodeBase58) {\n    if (decodeBase58.version === network.pubKeyHash)\n      return payments.p2pkh({ hash: decodeBase58.hash }).output;\n    if (decodeBase58.version === network.scriptHash)\n      return payments.p2sh({ hash: decodeBase58.hash }).output;\n  } else {\n    try {\n      decodeBech32 = fromBech32(address);\n    } catch (e) {}\n    if (decodeBech32) {\n      if (decodeBech32.prefix !== network.bech32)\n        throw new Error(address + ' has an invalid prefix');\n      if (decodeBech32.version === 0) {\n        if (decodeBech32.data.length === 20)\n          return payments.p2wpkh({ hash: decodeBech32.data }).output;\n        if (decodeBech32.data.length === 32)\n          return payments.p2wsh({ hash: decodeBech32.data }).output;\n      } else if (decodeBech32.version === 1) {\n        if (decodeBech32.data.length === 32)\n          return payments.p2tr({ pubkey: decodeBech32.data }).output;\n      } else if (\n        decodeBech32.version >= FUTURE_SEGWIT_MIN_VERSION &&\n        decodeBech32.version <= FUTURE_SEGWIT_MAX_VERSION &&\n        decodeBech32.data.length >= FUTURE_SEGWIT_MIN_SIZE &&\n        decodeBech32.data.length <= FUTURE_SEGWIT_MAX_SIZE\n      ) {\n        console.warn(FUTURE_SEGWIT_VERSION_WARNING);\n        return bscript.compile([\n          decodeBech32.version + FUTURE_SEGWIT_VERSION_DIFF,\n          decodeBech32.data,\n        ]);\n      }\n    }\n  }\n  throw new Error(address + ' has no matching Script');\n}\nexports.toOutputScript = toOutputScript;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.fastMerkleRoot = void 0;\n/**\n * Calculates the Merkle root of an array of buffers using a specified digest function.\n *\n * @param values - The array of buffers.\n * @param digestFn - The digest function used to calculate the hash of the concatenated buffers.\n * @returns The Merkle root as a buffer.\n * @throws {TypeError} If the values parameter is not an array or the digestFn parameter is not a function.\n */\nfunction fastMerkleRoot(values, digestFn) {\n  if (!Array.isArray(values)) throw TypeError('Expected values Array');\n  if (typeof digestFn !== 'function')\n    throw TypeError('Expected digest Function');\n  let length = values.length;\n  const results = values.concat();\n  while (length > 1) {\n    let j = 0;\n    for (let i = 0; i < length; i += 2, ++j) {\n      const left = results[i];\n      const right = i + 1 === length ? left : results[i + 1];\n      const data = Buffer.concat([left, right]);\n      results[j] = digestFn(data);\n    }\n    length = j;\n  }\n  return results[0];\n}\nexports.fastMerkleRoot = fastMerkleRoot;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Transaction = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst bscript = require('./script');\nconst script_1 = require('./script');\nconst types = require('./types');\nconst { typeforce } = types;\nfunction varSliceSize(someScript) {\n  const length = someScript.length;\n  return bufferutils_1.varuint.encodingLength(length) + length;\n}\nfunction vectorSize(someVector) {\n  const length = someVector.length;\n  return (\n    bufferutils_1.varuint.encodingLength(length) +\n    someVector.reduce((sum, witness) => {\n      return sum + varSliceSize(witness);\n    }, 0)\n  );\n}\nconst EMPTY_BUFFER = Buffer.allocUnsafe(0);\nconst EMPTY_WITNESS = [];\nconst ZERO = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000000',\n  'hex',\n);\nconst ONE = Buffer.from(\n  '0000000000000000000000000000000000000000000000000000000000000001',\n  'hex',\n);\nconst VALUE_UINT64_MAX = Buffer.from('ffffffffffffffff', 'hex');\nconst BLANK_OUTPUT = {\n  script: EMPTY_BUFFER,\n  valueBuffer: VALUE_UINT64_MAX,\n};\nfunction isOutput(out) {\n  return out.value !== undefined;\n}\n/**\n * Represents a Bitcoin transaction.\n */\nclass Transaction {\n  constructor() {\n    this.version = 1;\n    this.locktime = 0;\n    this.ins = [];\n    this.outs = [];\n  }\n  static fromBuffer(buffer, _NO_STRICT) {\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const tx = new Transaction();\n    tx.version = bufferReader.readInt32();\n    const marker = bufferReader.readUInt8();\n    const flag = bufferReader.readUInt8();\n    let hasWitnesses = false;\n    if (\n      marker === Transaction.ADVANCED_TRANSACTION_MARKER &&\n      flag === Transaction.ADVANCED_TRANSACTION_FLAG\n    ) {\n      hasWitnesses = true;\n    } else {\n      bufferReader.offset -= 2;\n    }\n    const vinLen = bufferReader.readVarInt();\n    for (let i = 0; i < vinLen; ++i) {\n      tx.ins.push({\n        hash: bufferReader.readSlice(32),\n        index: bufferReader.readUInt32(),\n        script: bufferReader.readVarSlice(),\n        sequence: bufferReader.readUInt32(),\n        witness: EMPTY_WITNESS,\n      });\n    }\n    const voutLen = bufferReader.readVarInt();\n    for (let i = 0; i < voutLen; ++i) {\n      tx.outs.push({\n        value: bufferReader.readUInt64(),\n        script: bufferReader.readVarSlice(),\n      });\n    }\n    if (hasWitnesses) {\n      for (let i = 0; i < vinLen; ++i) {\n        tx.ins[i].witness = bufferReader.readVector();\n      }\n      // was this pointless?\n      if (!tx.hasWitnesses())\n        throw new Error('Transaction has superfluous witness data');\n    }\n    tx.locktime = bufferReader.readUInt32();\n    if (_NO_STRICT) return tx;\n    if (bufferReader.offset !== buffer.length)\n      throw new Error('Transaction has unexpected data');\n    return tx;\n  }\n  static fromHex(hex) {\n    return Transaction.fromBuffer(Buffer.from(hex, 'hex'), false);\n  }\n  static isCoinbaseHash(buffer) {\n    typeforce(types.Hash256bit, buffer);\n    for (let i = 0; i < 32; ++i) {\n      if (buffer[i] !== 0) return false;\n    }\n    return true;\n  }\n  isCoinbase() {\n    return (\n      this.ins.length === 1 && Transaction.isCoinbaseHash(this.ins[0].hash)\n    );\n  }\n  addInput(hash, index, sequence, scriptSig) {\n    typeforce(\n      types.tuple(\n        types.Hash256bit,\n        types.UInt32,\n        types.maybe(types.UInt32),\n        types.maybe(types.Buffer),\n      ),\n      arguments,\n    );\n    if (types.Null(sequence)) {\n      sequence = Transaction.DEFAULT_SEQUENCE;\n    }\n    // Add the input and return the input's index\n    return (\n      this.ins.push({\n        hash,\n        index,\n        script: scriptSig || EMPTY_BUFFER,\n        sequence: sequence,\n        witness: EMPTY_WITNESS,\n      }) - 1\n    );\n  }\n  addOutput(scriptPubKey, value) {\n    typeforce(types.tuple(types.Buffer, types.Satoshi), arguments);\n    // Add the output and return the output's index\n    return (\n      this.outs.push({\n        script: scriptPubKey,\n        value,\n      }) - 1\n    );\n  }\n  hasWitnesses() {\n    return this.ins.some(x => {\n      return x.witness.length !== 0;\n    });\n  }\n  stripWitnesses() {\n    this.ins.forEach(input => {\n      input.witness = EMPTY_WITNESS; // Set witness data to an empty array\n    });\n  }\n  weight() {\n    const base = this.byteLength(false);\n    const total = this.byteLength(true);\n    return base * 3 + total;\n  }\n  virtualSize() {\n    return Math.ceil(this.weight() / 4);\n  }\n  byteLength(_ALLOW_WITNESS = true) {\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    return (\n      (hasWitnesses ? 10 : 8) +\n      bufferutils_1.varuint.encodingLength(this.ins.length) +\n      bufferutils_1.varuint.encodingLength(this.outs.length) +\n      this.ins.reduce((sum, input) => {\n        return sum + 40 + varSliceSize(input.script);\n      }, 0) +\n      this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0) +\n      (hasWitnesses\n        ? this.ins.reduce((sum, input) => {\n            return sum + vectorSize(input.witness);\n          }, 0)\n        : 0)\n    );\n  }\n  clone() {\n    const newTx = new Transaction();\n    newTx.version = this.version;\n    newTx.locktime = this.locktime;\n    newTx.ins = this.ins.map(txIn => {\n      return {\n        hash: txIn.hash,\n        index: txIn.index,\n        script: txIn.script,\n        sequence: txIn.sequence,\n        witness: txIn.witness,\n      };\n    });\n    newTx.outs = this.outs.map(txOut => {\n      return {\n        script: txOut.script,\n        value: txOut.value,\n      };\n    });\n    return newTx;\n  }\n  /**\n   * Hash transaction for signing a specific input.\n   *\n   * Bitcoin uses a different hash for each signed transaction input.\n   * This method copies the transaction, makes the necessary changes based on the\n   * hashType, and then hashes the result.\n   * This hash can then be used to sign the provided transaction input.\n   */\n  hashForSignature(inIndex, prevOutScript, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, /* types.UInt8 */ types.Number),\n      arguments,\n    );\n    // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L29\n    if (inIndex >= this.ins.length) return ONE;\n    // ignore OP_CODESEPARATOR\n    const ourScript = bscript.compile(\n      bscript.decompile(prevOutScript).filter(x => {\n        return x !== script_1.OPS.OP_CODESEPARATOR;\n      }),\n    );\n    const txTmp = this.clone();\n    // SIGHASH_NONE: ignore all outputs? (wildcard payee)\n    if ((hashType & 0x1f) === Transaction.SIGHASH_NONE) {\n      txTmp.outs = [];\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, i) => {\n        if (i === inIndex) return;\n        input.sequence = 0;\n      });\n      // SIGHASH_SINGLE: ignore all outputs, except at the same index?\n    } else if ((hashType & 0x1f) === Transaction.SIGHASH_SINGLE) {\n      // https://github.com/bitcoin/bitcoin/blob/master/src/test/sighash_tests.cpp#L60\n      if (inIndex >= this.outs.length) return ONE;\n      // truncate outputs after\n      txTmp.outs.length = inIndex + 1;\n      // \"blank\" outputs before\n      for (let i = 0; i < inIndex; i++) {\n        txTmp.outs[i] = BLANK_OUTPUT;\n      }\n      // ignore sequence numbers (except at inIndex)\n      txTmp.ins.forEach((input, y) => {\n        if (y === inIndex) return;\n        input.sequence = 0;\n      });\n    }\n    // SIGHASH_ANYONECANPAY: ignore inputs entirely?\n    if (hashType & Transaction.SIGHASH_ANYONECANPAY) {\n      txTmp.ins = [txTmp.ins[inIndex]];\n      txTmp.ins[0].script = ourScript;\n      // SIGHASH_ALL: only ignore input scripts\n    } else {\n      // \"blank\" others input scripts\n      txTmp.ins.forEach(input => {\n        input.script = EMPTY_BUFFER;\n      });\n      txTmp.ins[inIndex].script = ourScript;\n    }\n    // serialize and hash\n    const buffer = Buffer.allocUnsafe(txTmp.byteLength(false) + 4);\n    buffer.writeInt32LE(hashType, buffer.length - 4);\n    txTmp.__toBuffer(buffer, 0, false);\n    return bcrypto.hash256(buffer);\n  }\n  hashForWitnessV1(inIndex, prevOutScripts, values, hashType, leafHash, annex) {\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#common-signature-message\n    typeforce(\n      types.tuple(\n        types.UInt32,\n        typeforce.arrayOf(types.Buffer),\n        typeforce.arrayOf(types.Satoshi),\n        types.UInt32,\n      ),\n      arguments,\n    );\n    if (\n      values.length !== this.ins.length ||\n      prevOutScripts.length !== this.ins.length\n    ) {\n      throw new Error('Must supply prevout script and value for all inputs');\n    }\n    const outputType =\n      hashType === Transaction.SIGHASH_DEFAULT\n        ? Transaction.SIGHASH_ALL\n        : hashType & Transaction.SIGHASH_OUTPUT_MASK;\n    const inputType = hashType & Transaction.SIGHASH_INPUT_MASK;\n    const isAnyoneCanPay = inputType === Transaction.SIGHASH_ANYONECANPAY;\n    const isNone = outputType === Transaction.SIGHASH_NONE;\n    const isSingle = outputType === Transaction.SIGHASH_SINGLE;\n    let hashPrevouts = EMPTY_BUFFER;\n    let hashAmounts = EMPTY_BUFFER;\n    let hashScriptPubKeys = EMPTY_BUFFER;\n    let hashSequences = EMPTY_BUFFER;\n    let hashOutputs = EMPTY_BUFFER;\n    if (!isAnyoneCanPay) {\n      let bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        36 * this.ins.length,\n      );\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 * this.ins.length,\n      );\n      values.forEach(value => bufferWriter.writeUInt64(value));\n      hashAmounts = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        prevOutScripts.map(varSliceSize).reduce((a, b) => a + b),\n      );\n      prevOutScripts.forEach(prevOutScript =>\n        bufferWriter.writeVarSlice(prevOutScript),\n      );\n      hashScriptPubKeys = bcrypto.sha256(bufferWriter.end());\n      bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        4 * this.ins.length,\n      );\n      this.ins.forEach(txIn => bufferWriter.writeUInt32(txIn.sequence));\n      hashSequences = bcrypto.sha256(bufferWriter.end());\n    }\n    if (!(isNone || isSingle)) {\n      const txOutsSize = this.outs\n        .map(output => 8 + varSliceSize(output.script))\n        .reduce((a, b) => a + b);\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(txOutsSize);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    } else if (isSingle && inIndex < this.outs.length) {\n      const output = this.outs[inIndex];\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        8 + varSliceSize(output.script),\n      );\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.sha256(bufferWriter.end());\n    }\n    const spendType = (leafHash ? 2 : 0) + (annex ? 1 : 0);\n    // Length calculation from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-14\n    // With extension from:\n    // https://github.com/bitcoin/bips/blob/master/bip-0342.mediawiki#signature-validation\n    const sigMsgSize =\n      174 -\n      (isAnyoneCanPay ? 49 : 0) -\n      (isNone ? 32 : 0) +\n      (annex ? 32 : 0) +\n      (leafHash ? 37 : 0);\n    const sigMsgWriter = bufferutils_1.BufferWriter.withCapacity(sigMsgSize);\n    sigMsgWriter.writeUInt8(hashType);\n    // Transaction\n    sigMsgWriter.writeInt32(this.version);\n    sigMsgWriter.writeUInt32(this.locktime);\n    sigMsgWriter.writeSlice(hashPrevouts);\n    sigMsgWriter.writeSlice(hashAmounts);\n    sigMsgWriter.writeSlice(hashScriptPubKeys);\n    sigMsgWriter.writeSlice(hashSequences);\n    if (!(isNone || isSingle)) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // Input\n    sigMsgWriter.writeUInt8(spendType);\n    if (isAnyoneCanPay) {\n      const input = this.ins[inIndex];\n      sigMsgWriter.writeSlice(input.hash);\n      sigMsgWriter.writeUInt32(input.index);\n      sigMsgWriter.writeUInt64(values[inIndex]);\n      sigMsgWriter.writeVarSlice(prevOutScripts[inIndex]);\n      sigMsgWriter.writeUInt32(input.sequence);\n    } else {\n      sigMsgWriter.writeUInt32(inIndex);\n    }\n    if (annex) {\n      const bufferWriter = bufferutils_1.BufferWriter.withCapacity(\n        varSliceSize(annex),\n      );\n      bufferWriter.writeVarSlice(annex);\n      sigMsgWriter.writeSlice(bcrypto.sha256(bufferWriter.end()));\n    }\n    // Output\n    if (isSingle) {\n      sigMsgWriter.writeSlice(hashOutputs);\n    }\n    // BIP342 extension\n    if (leafHash) {\n      sigMsgWriter.writeSlice(leafHash);\n      sigMsgWriter.writeUInt8(0);\n      sigMsgWriter.writeUInt32(0xffffffff);\n    }\n    // Extra zero byte because:\n    // https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki#cite_note-19\n    return bcrypto.taggedHash(\n      'TapSighash',\n      Buffer.concat([Buffer.from([0x00]), sigMsgWriter.end()]),\n    );\n  }\n  hashForWitnessV0(inIndex, prevOutScript, value, hashType) {\n    typeforce(\n      types.tuple(types.UInt32, types.Buffer, types.Satoshi, types.UInt32),\n      arguments,\n    );\n    let tbuffer = Buffer.from([]);\n    let bufferWriter;\n    let hashOutputs = ZERO;\n    let hashPrevouts = ZERO;\n    let hashSequence = ZERO;\n    if (!(hashType & Transaction.SIGHASH_ANYONECANPAY)) {\n      tbuffer = Buffer.allocUnsafe(36 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeSlice(txIn.hash);\n        bufferWriter.writeUInt32(txIn.index);\n      });\n      hashPrevouts = bcrypto.hash256(tbuffer);\n    }\n    if (\n      !(hashType & Transaction.SIGHASH_ANYONECANPAY) &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      tbuffer = Buffer.allocUnsafe(4 * this.ins.length);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.ins.forEach(txIn => {\n        bufferWriter.writeUInt32(txIn.sequence);\n      });\n      hashSequence = bcrypto.hash256(tbuffer);\n    }\n    if (\n      (hashType & 0x1f) !== Transaction.SIGHASH_SINGLE &&\n      (hashType & 0x1f) !== Transaction.SIGHASH_NONE\n    ) {\n      const txOutsSize = this.outs.reduce((sum, output) => {\n        return sum + 8 + varSliceSize(output.script);\n      }, 0);\n      tbuffer = Buffer.allocUnsafe(txOutsSize);\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      this.outs.forEach(out => {\n        bufferWriter.writeUInt64(out.value);\n        bufferWriter.writeVarSlice(out.script);\n      });\n      hashOutputs = bcrypto.hash256(tbuffer);\n    } else if (\n      (hashType & 0x1f) === Transaction.SIGHASH_SINGLE &&\n      inIndex < this.outs.length\n    ) {\n      const output = this.outs[inIndex];\n      tbuffer = Buffer.allocUnsafe(8 + varSliceSize(output.script));\n      bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n      bufferWriter.writeUInt64(output.value);\n      bufferWriter.writeVarSlice(output.script);\n      hashOutputs = bcrypto.hash256(tbuffer);\n    }\n    tbuffer = Buffer.allocUnsafe(156 + varSliceSize(prevOutScript));\n    bufferWriter = new bufferutils_1.BufferWriter(tbuffer, 0);\n    const input = this.ins[inIndex];\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(hashPrevouts);\n    bufferWriter.writeSlice(hashSequence);\n    bufferWriter.writeSlice(input.hash);\n    bufferWriter.writeUInt32(input.index);\n    bufferWriter.writeVarSlice(prevOutScript);\n    bufferWriter.writeUInt64(value);\n    bufferWriter.writeUInt32(input.sequence);\n    bufferWriter.writeSlice(hashOutputs);\n    bufferWriter.writeUInt32(this.locktime);\n    bufferWriter.writeUInt32(hashType);\n    return bcrypto.hash256(tbuffer);\n  }\n  getHash(forWitness) {\n    // wtxid for coinbase is always 32 bytes of 0x00\n    if (forWitness && this.isCoinbase()) return Buffer.alloc(32, 0);\n    return bcrypto.hash256(this.__toBuffer(undefined, undefined, forWitness));\n  }\n  getId() {\n    // transaction hash's are displayed in reverse order\n    return (0, bufferutils_1.reverseBuffer)(this.getHash(false)).toString(\n      'hex',\n    );\n  }\n  toBuffer(buffer, initialOffset) {\n    return this.__toBuffer(buffer, initialOffset, true);\n  }\n  toHex() {\n    return this.toBuffer(undefined, undefined).toString('hex');\n  }\n  setInputScript(index, scriptSig) {\n    typeforce(types.tuple(types.Number, types.Buffer), arguments);\n    this.ins[index].script = scriptSig;\n  }\n  setWitness(index, witness) {\n    typeforce(types.tuple(types.Number, [types.Buffer]), arguments);\n    this.ins[index].witness = witness;\n  }\n  __toBuffer(buffer, initialOffset, _ALLOW_WITNESS = false) {\n    if (!buffer) buffer = Buffer.allocUnsafe(this.byteLength(_ALLOW_WITNESS));\n    const bufferWriter = new bufferutils_1.BufferWriter(\n      buffer,\n      initialOffset || 0,\n    );\n    bufferWriter.writeInt32(this.version);\n    const hasWitnesses = _ALLOW_WITNESS && this.hasWitnesses();\n    if (hasWitnesses) {\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_MARKER);\n      bufferWriter.writeUInt8(Transaction.ADVANCED_TRANSACTION_FLAG);\n    }\n    bufferWriter.writeVarInt(this.ins.length);\n    this.ins.forEach(txIn => {\n      bufferWriter.writeSlice(txIn.hash);\n      bufferWriter.writeUInt32(txIn.index);\n      bufferWriter.writeVarSlice(txIn.script);\n      bufferWriter.writeUInt32(txIn.sequence);\n    });\n    bufferWriter.writeVarInt(this.outs.length);\n    this.outs.forEach(txOut => {\n      if (isOutput(txOut)) {\n        bufferWriter.writeUInt64(txOut.value);\n      } else {\n        bufferWriter.writeSlice(txOut.valueBuffer);\n      }\n      bufferWriter.writeVarSlice(txOut.script);\n    });\n    if (hasWitnesses) {\n      this.ins.forEach(input => {\n        bufferWriter.writeVector(input.witness);\n      });\n    }\n    bufferWriter.writeUInt32(this.locktime);\n    // avoid slicing unless necessary\n    if (initialOffset !== undefined)\n      return buffer.slice(initialOffset, bufferWriter.offset);\n    return buffer;\n  }\n}\nexports.Transaction = Transaction;\nTransaction.DEFAULT_SEQUENCE = 0xffffffff;\nTransaction.SIGHASH_DEFAULT = 0x00;\nTransaction.SIGHASH_ALL = 0x01;\nTransaction.SIGHASH_NONE = 0x02;\nTransaction.SIGHASH_SINGLE = 0x03;\nTransaction.SIGHASH_ANYONECANPAY = 0x80;\nTransaction.SIGHASH_OUTPUT_MASK = 0x03;\nTransaction.SIGHASH_INPUT_MASK = 0x80;\nTransaction.ADVANCED_TRANSACTION_MARKER = 0x00;\nTransaction.ADVANCED_TRANSACTION_FLAG = 0x01;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Block = void 0;\nconst bufferutils_1 = require('./bufferutils');\nconst bcrypto = require('./crypto');\nconst merkle_1 = require('./merkle');\nconst transaction_1 = require('./transaction');\nconst types = require('./types');\nconst { typeforce } = types;\nconst errorMerkleNoTxes = new TypeError(\n  'Cannot compute merkle root for zero transactions',\n);\nconst errorWitnessNotSegwit = new TypeError(\n  'Cannot compute witness commit for non-segwit block',\n);\nclass Block {\n  constructor() {\n    this.version = 1;\n    this.prevHash = undefined;\n    this.merkleRoot = undefined;\n    this.timestamp = 0;\n    this.witnessCommit = undefined;\n    this.bits = 0;\n    this.nonce = 0;\n    this.transactions = undefined;\n  }\n  static fromBuffer(buffer) {\n    if (buffer.length < 80) throw new Error('Buffer too small (< 80 bytes)');\n    const bufferReader = new bufferutils_1.BufferReader(buffer);\n    const block = new Block();\n    block.version = bufferReader.readInt32();\n    block.prevHash = bufferReader.readSlice(32);\n    block.merkleRoot = bufferReader.readSlice(32);\n    block.timestamp = bufferReader.readUInt32();\n    block.bits = bufferReader.readUInt32();\n    block.nonce = bufferReader.readUInt32();\n    if (buffer.length === 80) return block;\n    const readTransaction = () => {\n      const tx = transaction_1.Transaction.fromBuffer(\n        bufferReader.buffer.slice(bufferReader.offset),\n        true,\n      );\n      bufferReader.offset += tx.byteLength();\n      return tx;\n    };\n    const nTransactions = bufferReader.readVarInt();\n    block.transactions = [];\n    for (let i = 0; i < nTransactions; ++i) {\n      const tx = readTransaction();\n      block.transactions.push(tx);\n    }\n    const witnessCommit = block.getWitnessCommit();\n    // This Block contains a witness commit\n    if (witnessCommit) block.witnessCommit = witnessCommit;\n    return block;\n  }\n  static fromHex(hex) {\n    return Block.fromBuffer(Buffer.from(hex, 'hex'));\n  }\n  static calculateTarget(bits) {\n    const exponent = ((bits & 0xff000000) >> 24) - 3;\n    const mantissa = bits & 0x007fffff;\n    const target = Buffer.alloc(32, 0);\n    target.writeUIntBE(mantissa, 29 - exponent, 3);\n    return target;\n  }\n  static calculateMerkleRoot(transactions, forWitness) {\n    typeforce([{ getHash: types.Function }], transactions);\n    if (transactions.length === 0) throw errorMerkleNoTxes;\n    if (forWitness && !txesHaveWitnessCommit(transactions))\n      throw errorWitnessNotSegwit;\n    const hashes = transactions.map(transaction =>\n      transaction.getHash(forWitness),\n    );\n    const rootHash = (0, merkle_1.fastMerkleRoot)(hashes, bcrypto.hash256);\n    return forWitness\n      ? bcrypto.hash256(\n          Buffer.concat([rootHash, transactions[0].ins[0].witness[0]]),\n        )\n      : rootHash;\n  }\n  getWitnessCommit() {\n    if (!txesHaveWitnessCommit(this.transactions)) return null;\n    // The merkle root for the witness data is in an OP_RETURN output.\n    // There is no rule for the index of the output, so use filter to find it.\n    // The root is prepended with 0xaa21a9ed so check for 0x6a24aa21a9ed\n    // If multiple commits are found, the output with highest index is assumed.\n    const witnessCommits = this.transactions[0].outs\n      .filter(out =>\n        out.script.slice(0, 6).equals(Buffer.from('6a24aa21a9ed', 'hex')),\n      )\n      .map(out => out.script.slice(6, 38));\n    if (witnessCommits.length === 0) return null;\n    // Use the commit with the highest output (should only be one though)\n    const result = witnessCommits[witnessCommits.length - 1];\n    if (!(result instanceof Buffer && result.length === 32)) return null;\n    return result;\n  }\n  hasWitnessCommit() {\n    if (\n      this.witnessCommit instanceof Buffer &&\n      this.witnessCommit.length === 32\n    )\n      return true;\n    if (this.getWitnessCommit() !== null) return true;\n    return false;\n  }\n  hasWitness() {\n    return anyTxHasWitness(this.transactions);\n  }\n  weight() {\n    const base = this.byteLength(false, false);\n    const total = this.byteLength(false, true);\n    return base * 3 + total;\n  }\n  byteLength(headersOnly, allowWitness = true) {\n    if (headersOnly || !this.transactions) return 80;\n    return (\n      80 +\n      bufferutils_1.varuint.encodingLength(this.transactions.length) +\n      this.transactions.reduce((a, x) => a + x.byteLength(allowWitness), 0)\n    );\n  }\n  getHash() {\n    return bcrypto.hash256(this.toBuffer(true));\n  }\n  getId() {\n    return (0, bufferutils_1.reverseBuffer)(this.getHash()).toString('hex');\n  }\n  getUTCDate() {\n    const date = new Date(0); // epoch\n    date.setUTCSeconds(this.timestamp);\n    return date;\n  }\n  // TODO: buffer, offset compatibility\n  toBuffer(headersOnly) {\n    const buffer = Buffer.allocUnsafe(this.byteLength(headersOnly));\n    const bufferWriter = new bufferutils_1.BufferWriter(buffer);\n    bufferWriter.writeInt32(this.version);\n    bufferWriter.writeSlice(this.prevHash);\n    bufferWriter.writeSlice(this.merkleRoot);\n    bufferWriter.writeUInt32(this.timestamp);\n    bufferWriter.writeUInt32(this.bits);\n    bufferWriter.writeUInt32(this.nonce);\n    if (headersOnly || !this.transactions) return buffer;\n    bufferutils_1.varuint.encode(\n      this.transactions.length,\n      buffer,\n      bufferWriter.offset,\n    );\n    bufferWriter.offset += bufferutils_1.varuint.encode.bytes;\n    this.transactions.forEach(tx => {\n      const txSize = tx.byteLength(); // TODO: extract from toBuffer?\n      tx.toBuffer(buffer, bufferWriter.offset);\n      bufferWriter.offset += txSize;\n    });\n    return buffer;\n  }\n  toHex(headersOnly) {\n    return this.toBuffer(headersOnly).toString('hex');\n  }\n  checkTxRoots() {\n    // If the Block has segwit transactions but no witness commit,\n    // there's no way it can be valid, so fail the check.\n    const hasWitnessCommit = this.hasWitnessCommit();\n    if (!hasWitnessCommit && this.hasWitness()) return false;\n    return (\n      this.__checkMerkleRoot() &&\n      (hasWitnessCommit ? this.__checkWitnessCommit() : true)\n    );\n  }\n  checkProofOfWork() {\n    const hash = (0, bufferutils_1.reverseBuffer)(this.getHash());\n    const target = Block.calculateTarget(this.bits);\n    return hash.compare(target) <= 0;\n  }\n  __checkMerkleRoot() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    const actualMerkleRoot = Block.calculateMerkleRoot(this.transactions);\n    return this.merkleRoot.compare(actualMerkleRoot) === 0;\n  }\n  __checkWitnessCommit() {\n    if (!this.transactions) throw errorMerkleNoTxes;\n    if (!this.hasWitnessCommit()) throw errorWitnessNotSegwit;\n    const actualWitnessCommit = Block.calculateMerkleRoot(\n      this.transactions,\n      true,\n    );\n    return this.witnessCommit.compare(actualWitnessCommit) === 0;\n  }\n}\nexports.Block = Block;\nfunction txesHaveWitnessCommit(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions[0] &&\n    transactions[0].ins &&\n    transactions[0].ins instanceof Array &&\n    transactions[0].ins[0] &&\n    transactions[0].ins[0].witness &&\n    transactions[0].ins[0].witness instanceof Array &&\n    transactions[0].ins[0].witness.length > 0\n  );\n}\nfunction anyTxHasWitness(transactions) {\n  return (\n    transactions instanceof Array &&\n    transactions.some(\n      tx =>\n        typeof tx === 'object' &&\n        tx.ins instanceof Array &&\n        tx.ins.some(\n          input =>\n            typeof input === 'object' &&\n            input.witness instanceof Array &&\n            input.witness.length > 0,\n        ),\n    )\n  );\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nvar GlobalTypes;\n(function(GlobalTypes) {\n  GlobalTypes[(GlobalTypes['UNSIGNED_TX'] = 0)] = 'UNSIGNED_TX';\n  GlobalTypes[(GlobalTypes['GLOBAL_XPUB'] = 1)] = 'GLOBAL_XPUB';\n})((GlobalTypes = exports.GlobalTypes || (exports.GlobalTypes = {})));\nexports.GLOBAL_TYPE_NAMES = ['unsignedTx', 'globalXpub'];\nvar InputTypes;\n(function(InputTypes) {\n  InputTypes[(InputTypes['NON_WITNESS_UTXO'] = 0)] = 'NON_WITNESS_UTXO';\n  InputTypes[(InputTypes['WITNESS_UTXO'] = 1)] = 'WITNESS_UTXO';\n  InputTypes[(InputTypes['PARTIAL_SIG'] = 2)] = 'PARTIAL_SIG';\n  InputTypes[(InputTypes['SIGHASH_TYPE'] = 3)] = 'SIGHASH_TYPE';\n  InputTypes[(InputTypes['REDEEM_SCRIPT'] = 4)] = 'REDEEM_SCRIPT';\n  InputTypes[(InputTypes['WITNESS_SCRIPT'] = 5)] = 'WITNESS_SCRIPT';\n  InputTypes[(InputTypes['BIP32_DERIVATION'] = 6)] = 'BIP32_DERIVATION';\n  InputTypes[(InputTypes['FINAL_SCRIPTSIG'] = 7)] = 'FINAL_SCRIPTSIG';\n  InputTypes[(InputTypes['FINAL_SCRIPTWITNESS'] = 8)] = 'FINAL_SCRIPTWITNESS';\n  InputTypes[(InputTypes['POR_COMMITMENT'] = 9)] = 'POR_COMMITMENT';\n  InputTypes[(InputTypes['TAP_KEY_SIG'] = 19)] = 'TAP_KEY_SIG';\n  InputTypes[(InputTypes['TAP_SCRIPT_SIG'] = 20)] = 'TAP_SCRIPT_SIG';\n  InputTypes[(InputTypes['TAP_LEAF_SCRIPT'] = 21)] = 'TAP_LEAF_SCRIPT';\n  InputTypes[(InputTypes['TAP_BIP32_DERIVATION'] = 22)] =\n    'TAP_BIP32_DERIVATION';\n  InputTypes[(InputTypes['TAP_INTERNAL_KEY'] = 23)] = 'TAP_INTERNAL_KEY';\n  InputTypes[(InputTypes['TAP_MERKLE_ROOT'] = 24)] = 'TAP_MERKLE_ROOT';\n})((InputTypes = exports.InputTypes || (exports.InputTypes = {})));\nexports.INPUT_TYPE_NAMES = [\n  'nonWitnessUtxo',\n  'witnessUtxo',\n  'partialSig',\n  'sighashType',\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'finalScriptSig',\n  'finalScriptWitness',\n  'porCommitment',\n  'tapKeySig',\n  'tapScriptSig',\n  'tapLeafScript',\n  'tapBip32Derivation',\n  'tapInternalKey',\n  'tapMerkleRoot',\n];\nvar OutputTypes;\n(function(OutputTypes) {\n  OutputTypes[(OutputTypes['REDEEM_SCRIPT'] = 0)] = 'REDEEM_SCRIPT';\n  OutputTypes[(OutputTypes['WITNESS_SCRIPT'] = 1)] = 'WITNESS_SCRIPT';\n  OutputTypes[(OutputTypes['BIP32_DERIVATION'] = 2)] = 'BIP32_DERIVATION';\n  OutputTypes[(OutputTypes['TAP_INTERNAL_KEY'] = 5)] = 'TAP_INTERNAL_KEY';\n  OutputTypes[(OutputTypes['TAP_TREE'] = 6)] = 'TAP_TREE';\n  OutputTypes[(OutputTypes['TAP_BIP32_DERIVATION'] = 7)] =\n    'TAP_BIP32_DERIVATION';\n})((OutputTypes = exports.OutputTypes || (exports.OutputTypes = {})));\nexports.OUTPUT_TYPE_NAMES = [\n  'redeemScript',\n  'witnessScript',\n  'bip32Derivation',\n  'tapInternalKey',\n  'tapTree',\n  'tapBip32Derivation',\n];\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst range = n => [...Array(n).keys()];\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.GlobalTypes.GLOBAL_XPUB) {\n    throw new Error(\n      'Decode Error: could not decode globalXpub with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 79 || ![2, 3].includes(keyVal.key[46])) {\n    throw new Error(\n      'Decode Error: globalXpub has invalid extended pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.value.length / 4) % 1 !== 0) {\n    throw new Error(\n      'Decode Error: Global GLOBAL_XPUB value length should be multiple of 4',\n    );\n  }\n  const extendedPubkey = keyVal.key.slice(1);\n  const data = {\n    masterFingerprint: keyVal.value.slice(0, 4),\n    extendedPubkey,\n    path: 'm',\n  };\n  for (const i of range(keyVal.value.length / 4 - 1)) {\n    const val = keyVal.value.readUInt32LE(i * 4 + 4);\n    const isHard = !!(val & 0x80000000);\n    const idx = val & 0x7fffffff;\n    data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n  }\n  return data;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const head = Buffer.from([typeFields_1.GlobalTypes.GLOBAL_XPUB]);\n  const key = Buffer.concat([head, data.extendedPubkey]);\n  const splitPath = data.path.split('/');\n  const value = Buffer.allocUnsafe(splitPath.length * 4);\n  data.masterFingerprint.copy(value, 0);\n  let offset = 4;\n  splitPath.slice(1).forEach(level => {\n    const isHard = level.slice(-1) === \"'\";\n    let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n    if (isHard) num += 0x80000000;\n    value.writeUInt32LE(num, offset);\n    offset += 4;\n  });\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ masterFingerprint: Buffer; extendedPubkey: Buffer; path: string; }';\nfunction check(data) {\n  const epk = data.extendedPubkey;\n  const mfp = data.masterFingerprint;\n  const p = data.path;\n  return (\n    Buffer.isBuffer(epk) &&\n    epk.length === 78 &&\n    [2, 3].indexOf(epk[45]) > -1 &&\n    Buffer.isBuffer(mfp) &&\n    mfp.length === 4 &&\n    typeof p === 'string' &&\n    !!p.match(/^m(\\/\\d+'?)*$/)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.extendedPubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.extendedPubkey.equals(item.extendedPubkey)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.GlobalTypes.UNSIGNED_TX]),\n    value: data.toBuffer(),\n  };\n}\nexports.encode = encode;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTSIG) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTSIG]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.finalScriptSig === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.FINAL_SCRIPTWITNESS) {\n    throw new Error(\n      'Decode Error: could not decode finalScriptWitness with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.FINAL_SCRIPTWITNESS]);\n  return {\n    key,\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return (\n    !!currentData && !!newData && currentData.finalScriptWitness === undefined\n  );\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.NON_WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode nonWitnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(data) {\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.NON_WITNESS_UTXO]),\n    value: data,\n  };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.nonWitnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.PARTIAL_SIG) {\n    throw new Error(\n      'Decode Error: could not decode partialSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (\n    !(keyVal.key.length === 34 || keyVal.key.length === 66) ||\n    ![2, 3, 4].includes(keyVal.key[1])\n  ) {\n    throw new Error(\n      'Decode Error: partialSig has invalid pubkey in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1);\n  return {\n    pubkey,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(pSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.PARTIAL_SIG]);\n  return {\n    key: Buffer.concat([head, pSig.pubkey]),\n    value: pSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.signature) &&\n    [33, 65].includes(data.pubkey.length) &&\n    [2, 3, 4].includes(data.pubkey[0]) &&\n    isDerSigWithSighash(data.signature)\n  );\n}\nexports.check = check;\nfunction isDerSigWithSighash(buf) {\n  if (!Buffer.isBuffer(buf) || buf.length < 9) return false;\n  if (buf[0] !== 0x30) return false;\n  if (buf.length !== buf[1] + 3) return false;\n  if (buf[2] !== 0x02) return false;\n  const rLen = buf[3];\n  if (rLen > 33 || rLen < 1) return false;\n  if (buf[3 + rLen + 1] !== 0x02) return false;\n  const sLen = buf[3 + rLen + 2];\n  if (sLen > 33 || sLen < 1) return false;\n  if (buf.length !== 3 + rLen + 2 + sLen + 2) return false;\n  return true;\n}\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.pubkey.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n}\nexports.canAddToArray = canAddToArray;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.POR_COMMITMENT) {\n    throw new Error(\n      'Decode Error: could not decode porCommitment with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.toString('utf8');\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.POR_COMMITMENT]);\n  return {\n    key,\n    value: Buffer.from(data, 'utf8'),\n  };\n}\nexports.encode = encode;\nexports.expected = 'string';\nfunction check(data) {\n  return typeof data === 'string';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.porCommitment === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.SIGHASH_TYPE) {\n    throw new Error(\n      'Decode Error: could not decode sighashType with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  return keyVal.value.readUInt32LE(0);\n}\nexports.decode = decode;\nfunction encode(data) {\n  const key = Buffer.from([typeFields_1.InputTypes.SIGHASH_TYPE]);\n  const value = Buffer.allocUnsafe(4);\n  value.writeUInt32LE(data, 0);\n  return {\n    key,\n    value,\n  };\n}\nexports.encode = encode;\nexports.expected = 'number';\nfunction check(data) {\n  return typeof data === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.sighashType === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_KEY_SIG ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapKeySig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error(\n      'Decode Error: tapKeySig not a valid 64-65-byte BIP340 signature',\n    );\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_KEY_SIG]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && (data.length === 64 || data.length === 65);\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapKeySig === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_LEAF_SCRIPT) {\n    throw new Error(\n      'Decode Error: could not decode tapLeafScript with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if ((keyVal.key.length - 2) % 32 !== 0) {\n    throw new Error(\n      'Decode Error: tapLeafScript has invalid control block in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const leafVersion = keyVal.value[keyVal.value.length - 1];\n  if ((keyVal.key[1] & 0xfe) !== leafVersion) {\n    throw new Error(\n      'Decode Error: tapLeafScript bad leaf version in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const script = keyVal.value.slice(0, -1);\n  const controlBlock = keyVal.key.slice(1);\n  return { controlBlock, script, leafVersion };\n}\nexports.decode = decode;\nfunction encode(tScript) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_LEAF_SCRIPT]);\n  const verBuf = Buffer.from([tScript.leafVersion]);\n  return {\n    key: Buffer.concat([head, tScript.controlBlock]),\n    value: Buffer.concat([tScript.script, verBuf]),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ controlBlock: Buffer; leafVersion: number, script: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.controlBlock) &&\n    (data.controlBlock.length - 1) % 32 === 0 &&\n    (data.controlBlock[0] & 0xfe) === data.leafVersion &&\n    Buffer.isBuffer(data.script)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString = item.controlBlock.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(v => v.controlBlock.equals(item.controlBlock)).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.InputTypes.TAP_MERKLE_ROOT ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapMerkleRoot with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (!check(keyVal.value)) {\n    throw new Error('Decode Error: tapMerkleRoot not a 32-byte hash');\n  }\n  return keyVal.value;\n}\nexports.decode = decode;\nfunction encode(value) {\n  const key = Buffer.from([typeFields_1.InputTypes.TAP_MERKLE_ROOT]);\n  return { key, value };\n}\nexports.encode = encode;\nexports.expected = 'Buffer';\nfunction check(data) {\n  return Buffer.isBuffer(data) && data.length === 32;\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapMerkleRoot === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.TAP_SCRIPT_SIG) {\n    throw new Error(\n      'Decode Error: could not decode tapScriptSig with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.key.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  if (keyVal.value.length !== 64 && keyVal.value.length !== 65) {\n    throw new Error(\n      'Decode Error: tapScriptSig has invalid signature in key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const pubkey = keyVal.key.slice(1, 33);\n  const leafHash = keyVal.key.slice(33);\n  return {\n    pubkey,\n    leafHash,\n    signature: keyVal.value,\n  };\n}\nexports.decode = decode;\nfunction encode(tSig) {\n  const head = Buffer.from([typeFields_1.InputTypes.TAP_SCRIPT_SIG]);\n  return {\n    key: Buffer.concat([head, tSig.pubkey, tSig.leafHash]),\n    value: tSig.signature,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ pubkey: Buffer; leafHash: Buffer; signature: Buffer; }';\nfunction check(data) {\n  return (\n    Buffer.isBuffer(data.pubkey) &&\n    Buffer.isBuffer(data.leafHash) &&\n    Buffer.isBuffer(data.signature) &&\n    data.pubkey.length === 32 &&\n    data.leafHash.length === 32 &&\n    (data.signature.length === 64 || data.signature.length === 65)\n  );\n}\nexports.check = check;\nfunction canAddToArray(array, item, dupeSet) {\n  const dupeString =\n    item.pubkey.toString('hex') + item.leafHash.toString('hex');\n  if (dupeSet.has(dupeString)) return false;\n  dupeSet.add(dupeString);\n  return (\n    array.filter(\n      v => v.pubkey.equals(item.pubkey) && v.leafHash.equals(item.leafHash),\n    ).length === 0\n  );\n}\nexports.canAddToArray = canAddToArray;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\n// Number.MAX_SAFE_INTEGER\nconst MAX_SAFE_INTEGER = 9007199254740991;\nfunction checkUInt53(n) {\n  if (n < 0 || n > MAX_SAFE_INTEGER || n % 1 !== 0)\n    throw new RangeError('value out of range');\n}\nfunction encode(_number, buffer, offset) {\n  checkUInt53(_number);\n  if (!buffer) buffer = Buffer.allocUnsafe(encodingLength(_number));\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  // 8 bit\n  if (_number < 0xfd) {\n    buffer.writeUInt8(_number, offset);\n    Object.assign(encode, { bytes: 1 });\n    // 16 bit\n  } else if (_number <= 0xffff) {\n    buffer.writeUInt8(0xfd, offset);\n    buffer.writeUInt16LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 3 });\n    // 32 bit\n  } else if (_number <= 0xffffffff) {\n    buffer.writeUInt8(0xfe, offset);\n    buffer.writeUInt32LE(_number, offset + 1);\n    Object.assign(encode, { bytes: 5 });\n    // 64 bit\n  } else {\n    buffer.writeUInt8(0xff, offset);\n    buffer.writeUInt32LE(_number >>> 0, offset + 1);\n    buffer.writeUInt32LE((_number / 0x100000000) | 0, offset + 5);\n    Object.assign(encode, { bytes: 9 });\n  }\n  return buffer;\n}\nexports.encode = encode;\nfunction decode(buffer, offset) {\n  if (!Buffer.isBuffer(buffer))\n    throw new TypeError('buffer must be a Buffer instance');\n  if (!offset) offset = 0;\n  const first = buffer.readUInt8(offset);\n  // 8 bit\n  if (first < 0xfd) {\n    Object.assign(decode, { bytes: 1 });\n    return first;\n    // 16 bit\n  } else if (first === 0xfd) {\n    Object.assign(decode, { bytes: 3 });\n    return buffer.readUInt16LE(offset + 1);\n    // 32 bit\n  } else if (first === 0xfe) {\n    Object.assign(decode, { bytes: 5 });\n    return buffer.readUInt32LE(offset + 1);\n    // 64 bit\n  } else {\n    Object.assign(decode, { bytes: 9 });\n    const lo = buffer.readUInt32LE(offset + 1);\n    const hi = buffer.readUInt32LE(offset + 5);\n    const _number = hi * 0x0100000000 + lo;\n    checkUInt53(_number);\n    return _number;\n  }\n}\nexports.decode = decode;\nfunction encodingLength(_number) {\n  checkUInt53(_number);\n  return _number < 0xfd\n    ? 1\n    : _number <= 0xffff\n    ? 3\n    : _number <= 0xffffffff\n    ? 5\n    : 9;\n}\nexports.encodingLength = encodingLength;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('./varint');\nexports.range = n => [...Array(n).keys()];\nfunction reverseBuffer(buffer) {\n  if (buffer.length < 1) return buffer;\n  let j = buffer.length - 1;\n  let tmp = 0;\n  for (let i = 0; i < buffer.length / 2; i++) {\n    tmp = buffer[i];\n    buffer[i] = buffer[j];\n    buffer[j] = tmp;\n    j--;\n  }\n  return buffer;\n}\nexports.reverseBuffer = reverseBuffer;\nfunction keyValsToBuffer(keyVals) {\n  const buffers = keyVals.map(keyValToBuffer);\n  buffers.push(Buffer.from([0]));\n  return Buffer.concat(buffers);\n}\nexports.keyValsToBuffer = keyValsToBuffer;\nfunction keyValToBuffer(keyVal) {\n  const keyLen = keyVal.key.length;\n  const valLen = keyVal.value.length;\n  const keyVarIntLen = varuint.encodingLength(keyLen);\n  const valVarIntLen = varuint.encodingLength(valLen);\n  const buffer = Buffer.allocUnsafe(\n    keyVarIntLen + keyLen + valVarIntLen + valLen,\n  );\n  varuint.encode(keyLen, buffer, 0);\n  keyVal.key.copy(buffer, keyVarIntLen);\n  varuint.encode(valLen, buffer, keyVarIntLen + keyLen);\n  keyVal.value.copy(buffer, keyVarIntLen + keyLen + valVarIntLen);\n  return buffer;\n}\nexports.keyValToBuffer = keyValToBuffer;\n// https://github.com/feross/buffer/blob/master/index.js#L1127\nfunction verifuint(value, max) {\n  if (typeof value !== 'number')\n    throw new Error('cannot write a non-number as a number');\n  if (value < 0)\n    throw new Error('specified a negative value for writing an unsigned value');\n  if (value > max) throw new Error('RangeError: value out of range');\n  if (Math.floor(value) !== value)\n    throw new Error('value has a fractional component');\n}\nfunction readUInt64LE(buffer, offset) {\n  const a = buffer.readUInt32LE(offset);\n  let b = buffer.readUInt32LE(offset + 4);\n  b *= 0x100000000;\n  verifuint(b + a, 0x001fffffffffffff);\n  return b + a;\n}\nexports.readUInt64LE = readUInt64LE;\nfunction writeUInt64LE(buffer, value, offset) {\n  verifuint(value, 0x001fffffffffffff);\n  buffer.writeInt32LE(value & -1, offset);\n  buffer.writeUInt32LE(Math.floor(value / 0x100000000), offset + 4);\n  return offset + 8;\n}\nexports.writeUInt64LE = writeUInt64LE;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst tools_1 = require('../tools');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (keyVal.key[0] !== typeFields_1.InputTypes.WITNESS_UTXO) {\n    throw new Error(\n      'Decode Error: could not decode witnessUtxo with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  const value = tools_1.readUInt64LE(keyVal.value, 0);\n  let _offset = 8;\n  const scriptLen = varuint.decode(keyVal.value, _offset);\n  _offset += varuint.encodingLength(scriptLen);\n  const script = keyVal.value.slice(_offset);\n  if (script.length !== scriptLen) {\n    throw new Error('Decode Error: WITNESS_UTXO script is not proper length');\n  }\n  return {\n    script,\n    value,\n  };\n}\nexports.decode = decode;\nfunction encode(data) {\n  const { script, value } = data;\n  const varintLen = varuint.encodingLength(script.length);\n  const result = Buffer.allocUnsafe(8 + varintLen + script.length);\n  tools_1.writeUInt64LE(result, value, 0);\n  varuint.encode(script.length, result, 8);\n  script.copy(result, 8 + varintLen);\n  return {\n    key: Buffer.from([typeFields_1.InputTypes.WITNESS_UTXO]),\n    value: result,\n  };\n}\nexports.encode = encode;\nexports.expected = '{ script: Buffer; value: number; }';\nfunction check(data) {\n  return Buffer.isBuffer(data.script) && typeof data.value === 'number';\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.witnessUtxo === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../../typeFields');\nconst varuint = require('../varint');\nfunction decode(keyVal) {\n  if (\n    keyVal.key[0] !== typeFields_1.OutputTypes.TAP_TREE ||\n    keyVal.key.length !== 1\n  ) {\n    throw new Error(\n      'Decode Error: could not decode tapTree with key 0x' +\n        keyVal.key.toString('hex'),\n    );\n  }\n  let _offset = 0;\n  const data = [];\n  while (_offset < keyVal.value.length) {\n    const depth = keyVal.value[_offset++];\n    const leafVersion = keyVal.value[_offset++];\n    const scriptLen = varuint.decode(keyVal.value, _offset);\n    _offset += varuint.encodingLength(scriptLen);\n    data.push({\n      depth,\n      leafVersion,\n      script: keyVal.value.slice(_offset, _offset + scriptLen),\n    });\n    _offset += scriptLen;\n  }\n  return { leaves: data };\n}\nexports.decode = decode;\nfunction encode(tree) {\n  const key = Buffer.from([typeFields_1.OutputTypes.TAP_TREE]);\n  const bufs = [].concat(\n    ...tree.leaves.map(tapLeaf => [\n      Buffer.of(tapLeaf.depth, tapLeaf.leafVersion),\n      varuint.encode(tapLeaf.script.length),\n      tapLeaf.script,\n    ]),\n  );\n  return {\n    key,\n    value: Buffer.concat(bufs),\n  };\n}\nexports.encode = encode;\nexports.expected =\n  '{ leaves: [{ depth: number; leafVersion: number, script: Buffer; }] }';\nfunction check(data) {\n  return (\n    Array.isArray(data.leaves) &&\n    data.leaves.every(\n      tapLeaf =>\n        tapLeaf.depth >= 0 &&\n        tapLeaf.depth <= 128 &&\n        (tapLeaf.leafVersion & 0xfe) === tapLeaf.leafVersion &&\n        Buffer.isBuffer(tapLeaf.script),\n    )\n  );\n}\nexports.check = check;\nfunction canAdd(currentData, newData) {\n  return !!currentData && !!newData && currentData.tapTree === undefined;\n}\nexports.canAdd = canAdd;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst range = n => [...Array(n).keys()];\nconst isValidDERKey = pubkey =>\n  (pubkey.length === 33 && [2, 3].includes(pubkey[0])) ||\n  (pubkey.length === 65 && 4 === pubkey[0]);\nfunction makeConverter(TYPE_BYTE, isValidPubkey = isValidDERKey) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode bip32Derivation with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    const pubkey = keyVal.key.slice(1);\n    if (!isValidPubkey(pubkey)) {\n      throw new Error(\n        'Decode Error: bip32Derivation has invalid pubkey in key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if ((keyVal.value.length / 4) % 1 !== 0) {\n      throw new Error(\n        'Decode Error: Input BIP32_DERIVATION value length should be multiple of 4',\n      );\n    }\n    const data = {\n      masterFingerprint: keyVal.value.slice(0, 4),\n      pubkey,\n      path: 'm',\n    };\n    for (const i of range(keyVal.value.length / 4 - 1)) {\n      const val = keyVal.value.readUInt32LE(i * 4 + 4);\n      const isHard = !!(val & 0x80000000);\n      const idx = val & 0x7fffffff;\n      data.path += '/' + idx.toString(10) + (isHard ? \"'\" : '');\n    }\n    return data;\n  }\n  function encode(data) {\n    const head = Buffer.from([TYPE_BYTE]);\n    const key = Buffer.concat([head, data.pubkey]);\n    const splitPath = data.path.split('/');\n    const value = Buffer.allocUnsafe(splitPath.length * 4);\n    data.masterFingerprint.copy(value, 0);\n    let offset = 4;\n    splitPath.slice(1).forEach(level => {\n      const isHard = level.slice(-1) === \"'\";\n      let num = 0x7fffffff & parseInt(isHard ? level.slice(0, -1) : level, 10);\n      if (isHard) num += 0x80000000;\n      value.writeUInt32LE(num, offset);\n      offset += 4;\n    });\n    return {\n      key,\n      value,\n    };\n  }\n  const expected =\n    '{ masterFingerprint: Buffer; pubkey: Buffer; path: string; }';\n  function check(data) {\n    return (\n      Buffer.isBuffer(data.pubkey) &&\n      Buffer.isBuffer(data.masterFingerprint) &&\n      typeof data.path === 'string' &&\n      isValidPubkey(data.pubkey) &&\n      data.masterFingerprint.length === 4\n    );\n  }\n  function canAddToArray(array, item, dupeSet) {\n    const dupeString = item.pubkey.toString('hex');\n    if (dupeSet.has(dupeString)) return false;\n    dupeSet.add(dupeString);\n    return array.filter(v => v.pubkey.equals(item.pubkey)).length === 0;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeChecker(pubkeyTypes) {\n  return checkPubkey;\n  function checkPubkey(keyVal) {\n    let pubkey;\n    if (pubkeyTypes.includes(keyVal.key[0])) {\n      pubkey = keyVal.key.slice(1);\n      if (\n        !(pubkey.length === 33 || pubkey.length === 65) ||\n        ![2, 3, 4].includes(pubkey[0])\n      ) {\n        throw new Error(\n          'Format Error: invalid pubkey in key 0x' + keyVal.key.toString('hex'),\n        );\n      }\n    }\n    return pubkey;\n  }\n}\nexports.makeChecker = makeChecker;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode redeemScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return !!currentData && !!newData && currentData.redeemScript === undefined;\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst varuint = require('../varint');\nconst bip32Derivation = require('./bip32Derivation');\nconst isValidBIP340Key = pubkey => pubkey.length === 32;\nfunction makeConverter(TYPE_BYTE) {\n  const parent = bip32Derivation.makeConverter(TYPE_BYTE, isValidBIP340Key);\n  function decode(keyVal) {\n    const nHashes = varuint.decode(keyVal.value);\n    const nHashesLen = varuint.encodingLength(nHashes);\n    const base = parent.decode({\n      key: keyVal.key,\n      value: keyVal.value.slice(nHashesLen + nHashes * 32),\n    });\n    const leafHashes = new Array(nHashes);\n    for (let i = 0, _offset = nHashesLen; i < nHashes; i++, _offset += 32) {\n      leafHashes[i] = keyVal.value.slice(_offset, _offset + 32);\n    }\n    return Object.assign({}, base, { leafHashes });\n  }\n  function encode(data) {\n    const base = parent.encode(data);\n    const nHashesLen = varuint.encodingLength(data.leafHashes.length);\n    const nHashesBuf = Buffer.allocUnsafe(nHashesLen);\n    varuint.encode(data.leafHashes.length, nHashesBuf);\n    const value = Buffer.concat([nHashesBuf, ...data.leafHashes, base.value]);\n    return Object.assign({}, base, { value });\n  }\n  const expected =\n    '{ ' +\n    'masterFingerprint: Buffer; ' +\n    'pubkey: Buffer; ' +\n    'path: string; ' +\n    'leafHashes: Buffer[]; ' +\n    '}';\n  function check(data) {\n    return (\n      Array.isArray(data.leafHashes) &&\n      data.leafHashes.every(\n        leafHash => Buffer.isBuffer(leafHash) && leafHash.length === 32,\n      ) &&\n      parent.check(data)\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAddToArray: parent.canAddToArray,\n  };\n}\nexports.makeConverter = makeConverter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE || keyVal.key.length !== 1) {\n      throw new Error(\n        'Decode Error: could not decode tapInternalKey with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    if (keyVal.value.length !== 32) {\n      throw new Error(\n        'Decode Error: tapInternalKey not a 32-byte x-only pubkey',\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(value) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return { key, value };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data) && data.length === 32;\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.tapInternalKey === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nfunction makeConverter(TYPE_BYTE) {\n  function decode(keyVal) {\n    if (keyVal.key[0] !== TYPE_BYTE) {\n      throw new Error(\n        'Decode Error: could not decode witnessScript with key 0x' +\n          keyVal.key.toString('hex'),\n      );\n    }\n    return keyVal.value;\n  }\n  function encode(data) {\n    const key = Buffer.from([TYPE_BYTE]);\n    return {\n      key,\n      value: data,\n    };\n  }\n  const expected = 'Buffer';\n  function check(data) {\n    return Buffer.isBuffer(data);\n  }\n  function canAdd(currentData, newData) {\n    return (\n      !!currentData && !!newData && currentData.witnessScript === undefined\n    );\n  }\n  return {\n    decode,\n    encode,\n    check,\n    expected,\n    canAdd,\n  };\n}\nexports.makeConverter = makeConverter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst typeFields_1 = require('../typeFields');\nconst globalXpub = require('./global/globalXpub');\nconst unsignedTx = require('./global/unsignedTx');\nconst finalScriptSig = require('./input/finalScriptSig');\nconst finalScriptWitness = require('./input/finalScriptWitness');\nconst nonWitnessUtxo = require('./input/nonWitnessUtxo');\nconst partialSig = require('./input/partialSig');\nconst porCommitment = require('./input/porCommitment');\nconst sighashType = require('./input/sighashType');\nconst tapKeySig = require('./input/tapKeySig');\nconst tapLeafScript = require('./input/tapLeafScript');\nconst tapMerkleRoot = require('./input/tapMerkleRoot');\nconst tapScriptSig = require('./input/tapScriptSig');\nconst witnessUtxo = require('./input/witnessUtxo');\nconst tapTree = require('./output/tapTree');\nconst bip32Derivation = require('./shared/bip32Derivation');\nconst checkPubkey = require('./shared/checkPubkey');\nconst redeemScript = require('./shared/redeemScript');\nconst tapBip32Derivation = require('./shared/tapBip32Derivation');\nconst tapInternalKey = require('./shared/tapInternalKey');\nconst witnessScript = require('./shared/witnessScript');\nconst globals = {\n  unsignedTx,\n  globalXpub,\n  // pass an Array of key bytes that require pubkey beside the key\n  checkPubkey: checkPubkey.makeChecker([]),\n};\nexports.globals = globals;\nconst inputs = {\n  nonWitnessUtxo,\n  partialSig,\n  sighashType,\n  finalScriptSig,\n  finalScriptWitness,\n  porCommitment,\n  witnessUtxo,\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.InputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.InputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.InputTypes.PARTIAL_SIG,\n    typeFields_1.InputTypes.BIP32_DERIVATION,\n  ]),\n  tapKeySig,\n  tapScriptSig,\n  tapLeafScript,\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.InputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n  ),\n  tapMerkleRoot,\n};\nexports.inputs = inputs;\nconst outputs = {\n  bip32Derivation: bip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ),\n  redeemScript: redeemScript.makeConverter(\n    typeFields_1.OutputTypes.REDEEM_SCRIPT,\n  ),\n  witnessScript: witnessScript.makeConverter(\n    typeFields_1.OutputTypes.WITNESS_SCRIPT,\n  ),\n  checkPubkey: checkPubkey.makeChecker([\n    typeFields_1.OutputTypes.BIP32_DERIVATION,\n  ]),\n  tapBip32Derivation: tapBip32Derivation.makeConverter(\n    typeFields_1.OutputTypes.TAP_BIP32_DERIVATION,\n  ),\n  tapTree,\n  tapInternalKey: tapInternalKey.makeConverter(\n    typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n  ),\n};\nexports.outputs = outputs;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nconst varuint = require('../converter/varint');\nconst typeFields_1 = require('../typeFields');\nfunction psbtFromBuffer(buffer, txGetter) {\n  let offset = 0;\n  function varSlice() {\n    const keyLen = varuint.decode(buffer, offset);\n    offset += varuint.encodingLength(keyLen);\n    const key = buffer.slice(offset, offset + keyLen);\n    offset += keyLen;\n    return key;\n  }\n  function readUInt32BE() {\n    const num = buffer.readUInt32BE(offset);\n    offset += 4;\n    return num;\n  }\n  function readUInt8() {\n    const num = buffer.readUInt8(offset);\n    offset += 1;\n    return num;\n  }\n  function getKeyValue() {\n    const key = varSlice();\n    const value = varSlice();\n    return {\n      key,\n      value,\n    };\n  }\n  function checkEndOfKeyValPairs() {\n    if (offset >= buffer.length) {\n      throw new Error('Format Error: Unexpected End of PSBT');\n    }\n    const isEnd = buffer.readUInt8(offset) === 0;\n    if (isEnd) {\n      offset++;\n    }\n    return isEnd;\n  }\n  if (readUInt32BE() !== 0x70736274) {\n    throw new Error('Format Error: Invalid Magic Number');\n  }\n  if (readUInt8() !== 0xff) {\n    throw new Error(\n      'Format Error: Magic Number must be followed by 0xff separator',\n    );\n  }\n  const globalMapKeyVals = [];\n  const globalKeyIndex = {};\n  while (!checkEndOfKeyValPairs()) {\n    const keyVal = getKeyValue();\n    const hexKey = keyVal.key.toString('hex');\n    if (globalKeyIndex[hexKey]) {\n      throw new Error(\n        'Format Error: Keys must be unique for global keymap: key ' + hexKey,\n      );\n    }\n    globalKeyIndex[hexKey] = 1;\n    globalMapKeyVals.push(keyVal);\n  }\n  const unsignedTxMaps = globalMapKeyVals.filter(\n    keyVal => keyVal.key[0] === typeFields_1.GlobalTypes.UNSIGNED_TX,\n  );\n  if (unsignedTxMaps.length !== 1) {\n    throw new Error('Format Error: Only one UNSIGNED_TX allowed');\n  }\n  const unsignedTx = txGetter(unsignedTxMaps[0].value);\n  // Get input and output counts to loop the respective fields\n  const { inputCount, outputCount } = unsignedTx.getInputOutputCounts();\n  const inputKeyVals = [];\n  const outputKeyVals = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const inputKeyIndex = {};\n    const input = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (inputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each input: ' +\n            'input index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      inputKeyIndex[hexKey] = 1;\n      input.push(keyVal);\n    }\n    inputKeyVals.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const outputKeyIndex = {};\n    const output = [];\n    while (!checkEndOfKeyValPairs()) {\n      const keyVal = getKeyValue();\n      const hexKey = keyVal.key.toString('hex');\n      if (outputKeyIndex[hexKey]) {\n        throw new Error(\n          'Format Error: Keys must be unique for each output: ' +\n            'output index ' +\n            index +\n            ' key ' +\n            hexKey,\n        );\n      }\n      outputKeyIndex[hexKey] = 1;\n      output.push(keyVal);\n    }\n    outputKeyVals.push(output);\n  }\n  return psbtFromKeyVals(unsignedTx, {\n    globalMapKeyVals,\n    inputKeyVals,\n    outputKeyVals,\n  });\n}\nexports.psbtFromBuffer = psbtFromBuffer;\nfunction checkKeyBuffer(type, keyBuf, keyNum) {\n  if (!keyBuf.equals(Buffer.from([keyNum]))) {\n    throw new Error(\n      `Format Error: Invalid ${type} key: ${keyBuf.toString('hex')}`,\n    );\n  }\n}\nexports.checkKeyBuffer = checkKeyBuffer;\nfunction psbtFromKeyVals(\n  unsignedTx,\n  { globalMapKeyVals, inputKeyVals, outputKeyVals },\n) {\n  // That was easy :-)\n  const globalMap = {\n    unsignedTx,\n  };\n  let txCount = 0;\n  for (const keyVal of globalMapKeyVals) {\n    // If a globalMap item needs pubkey, uncomment\n    // const pubkey = convert.globals.checkPubkey(keyVal);\n    switch (keyVal.key[0]) {\n      case typeFields_1.GlobalTypes.UNSIGNED_TX:\n        checkKeyBuffer(\n          'global',\n          keyVal.key,\n          typeFields_1.GlobalTypes.UNSIGNED_TX,\n        );\n        if (txCount > 0) {\n          throw new Error('Format Error: GlobalMap has multiple UNSIGNED_TX');\n        }\n        txCount++;\n        break;\n      case typeFields_1.GlobalTypes.GLOBAL_XPUB:\n        if (globalMap.globalXpub === undefined) {\n          globalMap.globalXpub = [];\n        }\n        globalMap.globalXpub.push(convert.globals.globalXpub.decode(keyVal));\n        break;\n      default:\n        // This will allow inclusion during serialization.\n        if (!globalMap.unknownKeyVals) globalMap.unknownKeyVals = [];\n        globalMap.unknownKeyVals.push(keyVal);\n    }\n  }\n  // Get input and output counts to loop the respective fields\n  const inputCount = inputKeyVals.length;\n  const outputCount = outputKeyVals.length;\n  const inputs = [];\n  const outputs = [];\n  // Get input fields\n  for (const index of tools_1.range(inputCount)) {\n    const input = {};\n    for (const keyVal of inputKeyVals[index]) {\n      convert.inputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.InputTypes.NON_WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.NON_WITNESS_UTXO,\n          );\n          if (input.nonWitnessUtxo !== undefined) {\n            throw new Error(\n              'Format Error: Input has multiple NON_WITNESS_UTXO',\n            );\n          }\n          input.nonWitnessUtxo = convert.inputs.nonWitnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_UTXO:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_UTXO,\n          );\n          if (input.witnessUtxo !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_UTXO');\n          }\n          input.witnessUtxo = convert.inputs.witnessUtxo.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.PARTIAL_SIG:\n          if (input.partialSig === undefined) {\n            input.partialSig = [];\n          }\n          input.partialSig.push(convert.inputs.partialSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.SIGHASH_TYPE:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.SIGHASH_TYPE,\n          );\n          if (input.sighashType !== undefined) {\n            throw new Error('Format Error: Input has multiple SIGHASH_TYPE');\n          }\n          input.sighashType = convert.inputs.sighashType.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.REDEEM_SCRIPT,\n          );\n          if (input.redeemScript !== undefined) {\n            throw new Error('Format Error: Input has multiple REDEEM_SCRIPT');\n          }\n          input.redeemScript = convert.inputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.WITNESS_SCRIPT,\n          );\n          if (input.witnessScript !== undefined) {\n            throw new Error('Format Error: Input has multiple WITNESS_SCRIPT');\n          }\n          input.witnessScript = convert.inputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.BIP32_DERIVATION:\n          if (input.bip32Derivation === undefined) {\n            input.bip32Derivation = [];\n          }\n          input.bip32Derivation.push(\n            convert.inputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTSIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTSIG,\n          );\n          input.finalScriptSig = convert.inputs.finalScriptSig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.FINAL_SCRIPTWITNESS:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.FINAL_SCRIPTWITNESS,\n          );\n          input.finalScriptWitness = convert.inputs.finalScriptWitness.decode(\n            keyVal,\n          );\n          break;\n        case typeFields_1.InputTypes.POR_COMMITMENT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.POR_COMMITMENT,\n          );\n          input.porCommitment = convert.inputs.porCommitment.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_KEY_SIG:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_KEY_SIG,\n          );\n          input.tapKeySig = convert.inputs.tapKeySig.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_SCRIPT_SIG:\n          if (input.tapScriptSig === undefined) {\n            input.tapScriptSig = [];\n          }\n          input.tapScriptSig.push(convert.inputs.tapScriptSig.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_LEAF_SCRIPT:\n          if (input.tapLeafScript === undefined) {\n            input.tapLeafScript = [];\n          }\n          input.tapLeafScript.push(convert.inputs.tapLeafScript.decode(keyVal));\n          break;\n        case typeFields_1.InputTypes.TAP_BIP32_DERIVATION:\n          if (input.tapBip32Derivation === undefined) {\n            input.tapBip32Derivation = [];\n          }\n          input.tapBip32Derivation.push(\n            convert.inputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.InputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_INTERNAL_KEY,\n          );\n          input.tapInternalKey = convert.inputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.InputTypes.TAP_MERKLE_ROOT:\n          checkKeyBuffer(\n            'input',\n            keyVal.key,\n            typeFields_1.InputTypes.TAP_MERKLE_ROOT,\n          );\n          input.tapMerkleRoot = convert.inputs.tapMerkleRoot.decode(keyVal);\n          break;\n        default:\n          // This will allow inclusion during serialization.\n          if (!input.unknownKeyVals) input.unknownKeyVals = [];\n          input.unknownKeyVals.push(keyVal);\n      }\n    }\n    inputs.push(input);\n  }\n  for (const index of tools_1.range(outputCount)) {\n    const output = {};\n    for (const keyVal of outputKeyVals[index]) {\n      convert.outputs.checkPubkey(keyVal);\n      switch (keyVal.key[0]) {\n        case typeFields_1.OutputTypes.REDEEM_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.REDEEM_SCRIPT,\n          );\n          if (output.redeemScript !== undefined) {\n            throw new Error('Format Error: Output has multiple REDEEM_SCRIPT');\n          }\n          output.redeemScript = convert.outputs.redeemScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.WITNESS_SCRIPT:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.WITNESS_SCRIPT,\n          );\n          if (output.witnessScript !== undefined) {\n            throw new Error('Format Error: Output has multiple WITNESS_SCRIPT');\n          }\n          output.witnessScript = convert.outputs.witnessScript.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.BIP32_DERIVATION:\n          if (output.bip32Derivation === undefined) {\n            output.bip32Derivation = [];\n          }\n          output.bip32Derivation.push(\n            convert.outputs.bip32Derivation.decode(keyVal),\n          );\n          break;\n        case typeFields_1.OutputTypes.TAP_INTERNAL_KEY:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_INTERNAL_KEY,\n          );\n          output.tapInternalKey = convert.outputs.tapInternalKey.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_TREE:\n          checkKeyBuffer(\n            'output',\n            keyVal.key,\n            typeFields_1.OutputTypes.TAP_TREE,\n          );\n          output.tapTree = convert.outputs.tapTree.decode(keyVal);\n          break;\n        case typeFields_1.OutputTypes.TAP_BIP32_DERIVATION:\n          if (output.tapBip32Derivation === undefined) {\n            output.tapBip32Derivation = [];\n          }\n          output.tapBip32Derivation.push(\n            convert.outputs.tapBip32Derivation.decode(keyVal),\n          );\n          break;\n        default:\n          if (!output.unknownKeyVals) output.unknownKeyVals = [];\n          output.unknownKeyVals.push(keyVal);\n      }\n    }\n    outputs.push(output);\n  }\n  return { globalMap, inputs, outputs };\n}\nexports.psbtFromKeyVals = psbtFromKeyVals;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst convert = require('../converter');\nconst tools_1 = require('../converter/tools');\nfunction psbtToBuffer({ globalMap, inputs, outputs }) {\n  const { globalKeyVals, inputKeyVals, outputKeyVals } = psbtToKeyVals({\n    globalMap,\n    inputs,\n    outputs,\n  });\n  const globalBuffer = tools_1.keyValsToBuffer(globalKeyVals);\n  const keyValsOrEmptyToBuffer = keyVals =>\n    keyVals.length === 0\n      ? [Buffer.from([0])]\n      : keyVals.map(tools_1.keyValsToBuffer);\n  const inputBuffers = keyValsOrEmptyToBuffer(inputKeyVals);\n  const outputBuffers = keyValsOrEmptyToBuffer(outputKeyVals);\n  const header = Buffer.allocUnsafe(5);\n  header.writeUIntBE(0x70736274ff, 0, 5);\n  return Buffer.concat(\n    [header, globalBuffer].concat(inputBuffers, outputBuffers),\n  );\n}\nexports.psbtToBuffer = psbtToBuffer;\nconst sortKeyVals = (a, b) => {\n  return a.key.compare(b.key);\n};\nfunction keyValsFromMap(keyValMap, converterFactory) {\n  const keyHexSet = new Set();\n  const keyVals = Object.entries(keyValMap).reduce((result, [key, value]) => {\n    if (key === 'unknownKeyVals') return result;\n    // We are checking for undefined anyways. So ignore TS error\n    // @ts-ignore\n    const converter = converterFactory[key];\n    if (converter === undefined) return result;\n    const encodedKeyVals = (Array.isArray(value) ? value : [value]).map(\n      converter.encode,\n    );\n    const keyHexes = encodedKeyVals.map(kv => kv.key.toString('hex'));\n    keyHexes.forEach(hex => {\n      if (keyHexSet.has(hex))\n        throw new Error('Serialize Error: Duplicate key: ' + hex);\n      keyHexSet.add(hex);\n    });\n    return result.concat(encodedKeyVals);\n  }, []);\n  // Get other keyVals that have not yet been gotten\n  const otherKeyVals = keyValMap.unknownKeyVals\n    ? keyValMap.unknownKeyVals.filter(keyVal => {\n        return !keyHexSet.has(keyVal.key.toString('hex'));\n      })\n    : [];\n  return keyVals.concat(otherKeyVals).sort(sortKeyVals);\n}\nfunction psbtToKeyVals({ globalMap, inputs, outputs }) {\n  // First parse the global keyVals\n  // Get any extra keyvals to pass along\n  return {\n    globalKeyVals: keyValsFromMap(globalMap, convert.globals),\n    inputKeyVals: inputs.map(i => keyValsFromMap(i, convert.inputs)),\n    outputKeyVals: outputs.map(o => keyValsFromMap(o, convert.outputs)),\n  };\n}\nexports.psbtToKeyVals = psbtToKeyVals;\n", "'use strict';\nfunction __export(m) {\n  for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];\n}\nObject.defineProperty(exports, '__esModule', { value: true });\n__export(require('./fromBuffer'));\n__export(require('./toBuffer'));\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst parser_1 = require('../parser');\nfunction combine(psbts) {\n  const self = psbts[0];\n  const selfKeyVals = parser_1.psbtToKeyVals(self);\n  const others = psbts.slice(1);\n  if (others.length === 0) throw new Error('Combine: Nothing to combine');\n  const selfTx = getTx(self);\n  if (selfTx === undefined) {\n    throw new Error('Combine: Self missing transaction');\n  }\n  const selfGlobalSet = getKeySet(selfKeyVals.globalKeyVals);\n  const selfInputSets = selfKeyVals.inputKeyVals.map(getKeySet);\n  const selfOutputSets = selfKeyVals.outputKeyVals.map(getKeySet);\n  for (const other of others) {\n    const otherTx = getTx(other);\n    if (\n      otherTx === undefined ||\n      !otherTx.toBuffer().equals(selfTx.toBuffer())\n    ) {\n      throw new Error(\n        'Combine: One of the Psbts does not have the same transaction.',\n      );\n    }\n    const otherKeyVals = parser_1.psbtToKeyVals(other);\n    const otherGlobalSet = getKeySet(otherKeyVals.globalKeyVals);\n    otherGlobalSet.forEach(\n      keyPusher(\n        selfGlobalSet,\n        selfKeyVals.globalKeyVals,\n        otherKeyVals.globalKeyVals,\n      ),\n    );\n    const otherInputSets = otherKeyVals.inputKeyVals.map(getKeySet);\n    otherInputSets.forEach((inputSet, idx) =>\n      inputSet.forEach(\n        keyPusher(\n          selfInputSets[idx],\n          selfKeyVals.inputKeyVals[idx],\n          otherKeyVals.inputKeyVals[idx],\n        ),\n      ),\n    );\n    const otherOutputSets = otherKeyVals.outputKeyVals.map(getKeySet);\n    otherOutputSets.forEach((outputSet, idx) =>\n      outputSet.forEach(\n        keyPusher(\n          selfOutputSets[idx],\n          selfKeyVals.outputKeyVals[idx],\n          otherKeyVals.outputKeyVals[idx],\n        ),\n      ),\n    );\n  }\n  return parser_1.psbtFromKeyVals(selfTx, {\n    globalMapKeyVals: selfKeyVals.globalKeyVals,\n    inputKeyVals: selfKeyVals.inputKeyVals,\n    outputKeyVals: selfKeyVals.outputKeyVals,\n  });\n}\nexports.combine = combine;\nfunction keyPusher(selfSet, selfKeyVals, otherKeyVals) {\n  return key => {\n    if (selfSet.has(key)) return;\n    const newKv = otherKeyVals.filter(kv => kv.key.toString('hex') === key)[0];\n    selfKeyVals.push(newKv);\n    selfSet.add(key);\n  };\n}\nfunction getTx(psbt) {\n  return psbt.globalMap.unsignedTx;\n}\nfunction getKeySet(keyVals) {\n  const set = new Set();\n  keyVals.forEach(keyVal => {\n    const hex = keyVal.key.toString('hex');\n    if (set.has(hex))\n      throw new Error('Combine: KeyValue Map keys should be unique');\n    set.add(hex);\n  });\n  return set;\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst converter = require('./converter');\nfunction checkForInput(inputs, inputIndex) {\n  const input = inputs[inputIndex];\n  if (input === undefined) throw new Error(`No input #${inputIndex}`);\n  return input;\n}\nexports.checkForInput = checkForInput;\nfunction checkForOutput(outputs, outputIndex) {\n  const output = outputs[outputIndex];\n  if (output === undefined) throw new Error(`No output #${outputIndex}`);\n  return output;\n}\nexports.checkForOutput = checkForOutput;\nfunction checkHasKey(checkKeyVal, keyVals, enumLength) {\n  if (checkKeyVal.key[0] < enumLength) {\n    throw new Error(\n      `Use the method for your specific key instead of addUnknownKeyVal*`,\n    );\n  }\n  if (\n    keyVals &&\n    keyVals.filter(kv => kv.key.equals(checkKeyVal.key)).length !== 0\n  ) {\n    throw new Error(`Duplicate Key: ${checkKeyVal.key.toString('hex')}`);\n  }\n}\nexports.checkHasKey = checkHasKey;\nfunction getEnumLength(myenum) {\n  let count = 0;\n  Object.keys(myenum).forEach(val => {\n    if (Number(isNaN(Number(val)))) {\n      count++;\n    }\n  });\n  return count;\n}\nexports.getEnumLength = getEnumLength;\nfunction inputCheckUncleanFinalized(inputIndex, input) {\n  let result = false;\n  if (input.nonWitnessUtxo || input.witnessUtxo) {\n    const needScriptSig = !!input.redeemScript;\n    const needWitnessScript = !!input.witnessScript;\n    const scriptSigOK = !needScriptSig || !!input.finalScriptSig;\n    const witnessScriptOK = !needWitnessScript || !!input.finalScriptWitness;\n    const hasOneFinal = !!input.finalScriptSig || !!input.finalScriptWitness;\n    result = scriptSigOK && witnessScriptOK && hasOneFinal;\n  }\n  if (result === false) {\n    throw new Error(\n      `Input #${inputIndex} has too much or too little data to clean`,\n    );\n  }\n}\nexports.inputCheckUncleanFinalized = inputCheckUncleanFinalized;\nfunction throwForUpdateMaker(typeName, name, expected, data) {\n  throw new Error(\n    `Data for ${typeName} key ${name} is incorrect: Expected ` +\n      `${expected} and got ${JSON.stringify(data)}`,\n  );\n}\nfunction updateMaker(typeName) {\n  return (updateData, mainData) => {\n    for (const name of Object.keys(updateData)) {\n      // @ts-ignore\n      const data = updateData[name];\n      // @ts-ignore\n      const { canAdd, canAddToArray, check, expected } =\n        // @ts-ignore\n        converter[typeName + 's'][name] || {};\n      const isArray = !!canAddToArray;\n      // If unknown data. ignore and do not add\n      if (check) {\n        if (isArray) {\n          if (\n            !Array.isArray(data) ||\n            // @ts-ignore\n            (mainData[name] && !Array.isArray(mainData[name]))\n          ) {\n            throw new Error(`Key type ${name} must be an array`);\n          }\n          if (!data.every(check)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          // @ts-ignore\n          const arr = mainData[name] || [];\n          const dupeCheckSet = new Set();\n          if (!data.every(v => canAddToArray(arr, v, dupeCheckSet))) {\n            throw new Error('Can not add duplicate data to array');\n          }\n          // @ts-ignore\n          mainData[name] = arr.concat(data);\n        } else {\n          if (!check(data)) {\n            throwForUpdateMaker(typeName, name, expected, data);\n          }\n          if (!canAdd(mainData, data)) {\n            throw new Error(`Can not add duplicate data to ${typeName}`);\n          }\n          // @ts-ignore\n          mainData[name] = data;\n        }\n      }\n    }\n  };\n}\nexports.updateGlobal = updateMaker('global');\nexports.updateInput = updateMaker('input');\nexports.updateOutput = updateMaker('output');\nfunction addInputAttributes(inputs, data) {\n  const index = inputs.length - 1;\n  const input = checkForInput(inputs, index);\n  exports.updateInput(data, input);\n}\nexports.addInputAttributes = addInputAttributes;\nfunction addOutputAttributes(outputs, data) {\n  const index = outputs.length - 1;\n  const output = checkForOutput(outputs, index);\n  exports.updateOutput(data, output);\n}\nexports.addOutputAttributes = addOutputAttributes;\nfunction defaultVersionSetter(version, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Version: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(version, 0);\n  return txBuf;\n}\nexports.defaultVersionSetter = defaultVersionSetter;\nfunction defaultLocktimeSetter(locktime, txBuf) {\n  if (!Buffer.isBuffer(txBuf) || txBuf.length < 4) {\n    throw new Error('Set Locktime: Invalid Transaction');\n  }\n  txBuf.writeUInt32LE(locktime, txBuf.length - 4);\n  return txBuf;\n}\nexports.defaultLocktimeSetter = defaultLocktimeSetter;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nconst combiner_1 = require('./combiner');\nconst parser_1 = require('./parser');\nconst typeFields_1 = require('./typeFields');\nconst utils_1 = require('./utils');\nclass Psbt {\n  constructor(tx) {\n    this.inputs = [];\n    this.outputs = [];\n    this.globalMap = {\n      unsignedTx: tx,\n    };\n  }\n  static fromBase64(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromHex(data, txFromBuffer) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, txFromBuffer);\n  }\n  static fromBuffer(buffer, txFromBuffer) {\n    const results = parser_1.psbtFromBuffer(buffer, txFromBuffer);\n    const psbt = new this(results.globalMap.unsignedTx);\n    Object.assign(psbt, results);\n    return psbt;\n  }\n  toBase64() {\n    const buffer = this.toBuffer();\n    return buffer.toString('base64');\n  }\n  toHex() {\n    const buffer = this.toBuffer();\n    return buffer.toString('hex');\n  }\n  toBuffer() {\n    return parser_1.psbtToBuffer(this);\n  }\n  updateGlobal(updateData) {\n    utils_1.updateGlobal(updateData, this.globalMap);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.updateInput(updateData, input);\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.updateOutput(updateData, output);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    utils_1.checkHasKey(\n      keyVal,\n      this.globalMap.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.GlobalTypes),\n    );\n    if (!this.globalMap.unknownKeyVals) this.globalMap.unknownKeyVals = [];\n    this.globalMap.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      input.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.InputTypes),\n    );\n    if (!input.unknownKeyVals) input.unknownKeyVals = [];\n    input.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    const output = utils_1.checkForOutput(this.outputs, outputIndex);\n    utils_1.checkHasKey(\n      keyVal,\n      output.unknownKeyVals,\n      utils_1.getEnumLength(typeFields_1.OutputTypes),\n    );\n    if (!output.unknownKeyVals) output.unknownKeyVals = [];\n    output.unknownKeyVals.push(keyVal);\n    return this;\n  }\n  addInput(inputData) {\n    this.globalMap.unsignedTx.addInput(inputData);\n    this.inputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = inputData.unknownKeyVals || [];\n    const inputIndex = this.inputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToInput(inputIndex, keyVal),\n    );\n    utils_1.addInputAttributes(this.inputs, inputData);\n    return this;\n  }\n  addOutput(outputData) {\n    this.globalMap.unsignedTx.addOutput(outputData);\n    this.outputs.push({\n      unknownKeyVals: [],\n    });\n    const addKeyVals = outputData.unknownKeyVals || [];\n    const outputIndex = this.outputs.length - 1;\n    if (!Array.isArray(addKeyVals)) {\n      throw new Error('unknownKeyVals must be an Array');\n    }\n    addKeyVals.forEach(keyVal =>\n      this.addUnknownKeyValToOutput(outputIndex, keyVal),\n    );\n    utils_1.addOutputAttributes(this.outputs, outputData);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    const input = utils_1.checkForInput(this.inputs, inputIndex);\n    utils_1.inputCheckUncleanFinalized(inputIndex, input);\n    for (const key of Object.keys(input)) {\n      if (\n        ![\n          'witnessUtxo',\n          'nonWitnessUtxo',\n          'finalScriptSig',\n          'finalScriptWitness',\n          'unknownKeyVals',\n        ].includes(key)\n      ) {\n        // @ts-ignore\n        delete input[key];\n      }\n    }\n    return this;\n  }\n  combine(...those) {\n    // Combine this with those.\n    // Return self for chaining.\n    const result = combiner_1.combine([this].concat(those));\n    Object.assign(this, result);\n    return this;\n  }\n  getTransaction() {\n    return this.globalMap.unsignedTx.toBuffer();\n  }\n}\nexports.Psbt = Psbt;\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.signatureBlocksAction =\n  exports.checkInputForSig =\n  exports.pubkeyInScript =\n  exports.pubkeyPositionInScript =\n  exports.witnessStackToScriptWitness =\n  exports.isP2TR =\n  exports.isP2SHScript =\n  exports.isP2WSHScript =\n  exports.isP2WPKH =\n  exports.isP2PKH =\n  exports.isP2PK =\n  exports.isP2MS =\n    void 0;\nconst varuint = require('bip174/src/lib/converter/varint');\nconst bscript = require('../script');\nconst transaction_1 = require('../transaction');\nconst crypto_1 = require('../crypto');\nconst payments = require('../payments');\nfunction isPaymentFactory(payment) {\n  return script => {\n    try {\n      payment({ output: script });\n      return true;\n    } catch (err) {\n      return false;\n    }\n  };\n}\nexports.isP2MS = isPaymentFactory(payments.p2ms);\nexports.isP2PK = isPaymentFactory(payments.p2pk);\nexports.isP2PKH = isPaymentFactory(payments.p2pkh);\nexports.isP2WPKH = isPaymentFactory(payments.p2wpkh);\nexports.isP2WSHScript = isPaymentFactory(payments.p2wsh);\nexports.isP2SHScript = isPaymentFactory(payments.p2sh);\nexports.isP2TR = isPaymentFactory(payments.p2tr);\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The script witness as a Buffer.\n */\n/**\n * Converts a witness stack to a script witness.\n * @param witness The witness stack to convert.\n * @returns The converted script witness.\n */\nfunction witnessStackToScriptWitness(witness) {\n  let buffer = Buffer.allocUnsafe(0);\n  function writeSlice(slice) {\n    buffer = Buffer.concat([buffer, Buffer.from(slice)]);\n  }\n  function writeVarInt(i) {\n    const currentLen = buffer.length;\n    const varintLen = varuint.encodingLength(i);\n    buffer = Buffer.concat([buffer, Buffer.allocUnsafe(varintLen)]);\n    varuint.encode(i, buffer, currentLen);\n  }\n  function writeVarSlice(slice) {\n    writeVarInt(slice.length);\n    writeSlice(slice);\n  }\n  function writeVector(vector) {\n    writeVarInt(vector.length);\n    vector.forEach(writeVarSlice);\n  }\n  writeVector(witness);\n  return buffer;\n}\nexports.witnessStackToScriptWitness = witnessStackToScriptWitness;\n/**\n * Finds the position of a public key in a script.\n * @param pubkey The public key to search for.\n * @param script The script to search in.\n * @returns The index of the public key in the script, or -1 if not found.\n * @throws {Error} If there is an unknown script error.\n */\nfunction pubkeyPositionInScript(pubkey, script) {\n  const pubkeyHash = (0, crypto_1.hash160)(pubkey);\n  const pubkeyXOnly = pubkey.slice(1, 33); // slice before calling?\n  const decompiled = bscript.decompile(script);\n  if (decompiled === null) throw new Error('Unknown script error');\n  return decompiled.findIndex(element => {\n    if (typeof element === 'number') return false;\n    return (\n      element.equals(pubkey) ||\n      element.equals(pubkeyHash) ||\n      element.equals(pubkeyXOnly)\n    );\n  });\n}\nexports.pubkeyPositionInScript = pubkeyPositionInScript;\n/**\n * Checks if a public key is present in a script.\n * @param pubkey The public key to check.\n * @param script The script to search in.\n * @returns A boolean indicating whether the public key is present in the script.\n */\nfunction pubkeyInScript(pubkey, script) {\n  return pubkeyPositionInScript(pubkey, script) !== -1;\n}\nexports.pubkeyInScript = pubkeyInScript;\n/**\n * Checks if an input contains a signature for a specific action.\n * @param input - The input to check.\n * @param action - The action to check for.\n * @returns A boolean indicating whether the input contains a signature for the specified action.\n */\nfunction checkInputForSig(input, action) {\n  const pSigs = extractPartialSigs(input);\n  return pSigs.some(pSig =>\n    signatureBlocksAction(pSig, bscript.signature.decode, action),\n  );\n}\nexports.checkInputForSig = checkInputForSig;\n/**\n * Determines if a given action is allowed for a signature block.\n * @param signature - The signature block.\n * @param signatureDecodeFn - The function used to decode the signature.\n * @param action - The action to be checked.\n * @returns True if the action is allowed, false otherwise.\n */\nfunction signatureBlocksAction(signature, signatureDecodeFn, action) {\n  const { hashType } = signatureDecodeFn(signature);\n  const whitelist = [];\n  const isAnyoneCanPay =\n    hashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY;\n  if (isAnyoneCanPay) whitelist.push('addInput');\n  const hashMod = hashType & 0x1f;\n  switch (hashMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n    case transaction_1.Transaction.SIGHASH_NONE:\n      whitelist.push('addOutput');\n      whitelist.push('setInputSequence');\n      break;\n  }\n  if (whitelist.indexOf(action) === -1) {\n    return true;\n  }\n  return false;\n}\nexports.signatureBlocksAction = signatureBlocksAction;\n/**\n * Extracts the signatures from a PsbtInput object.\n * If the input has partial signatures, it returns an array of the signatures.\n * If the input does not have partial signatures, it checks if it has a finalScriptSig or finalScriptWitness.\n * If it does, it extracts the signatures from the final scripts and returns them.\n * If none of the above conditions are met, it returns an empty array.\n *\n * @param input - The PsbtInput object from which to extract the signatures.\n * @returns An array of signatures extracted from the PsbtInput object.\n */\nfunction extractPartialSigs(input) {\n  let pSigs = [];\n  if ((input.partialSig || []).length === 0) {\n    if (!input.finalScriptSig && !input.finalScriptWitness) return [];\n    pSigs = getPsigsFromInputFinalScripts(input);\n  } else {\n    pSigs = input.partialSig;\n  }\n  return pSigs.map(p => p.signature);\n}\n/**\n * Retrieves the partial signatures (Psigs) from the input's final scripts.\n * Psigs are extracted from both the final scriptSig and final scriptWitness of the input.\n * Only canonical script signatures are considered.\n *\n * @param input - The PsbtInput object representing the input.\n * @returns An array of PartialSig objects containing the extracted Psigs.\n */\nfunction getPsigsFromInputFinalScripts(input) {\n  const scriptItems = !input.finalScriptSig\n    ? []\n    : bscript.decompile(input.finalScriptSig) || [];\n  const witnessItems = !input.finalScriptWitness\n    ? []\n    : bscript.decompile(input.finalScriptWitness) || [];\n  return scriptItems\n    .concat(witnessItems)\n    .filter(item => {\n      return Buffer.isBuffer(item) && bscript.isCanonicalScriptSignature(item);\n    })\n    .map(sig => ({ signature: sig }));\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.checkTaprootInputForSigs =\n  exports.tapTreeFromList =\n  exports.tapTreeToList =\n  exports.tweakInternalPubKey =\n  exports.checkTaprootOutputFields =\n  exports.checkTaprootInputFields =\n  exports.isTaprootOutput =\n  exports.isTaprootInput =\n  exports.serializeTaprootSignature =\n  exports.tapScriptFinalizer =\n  exports.toXOnly =\n    void 0;\nconst types_1 = require('../types');\nconst transaction_1 = require('../transaction');\nconst psbtutils_1 = require('./psbtutils');\nconst bip341_1 = require('../payments/bip341');\nconst payments_1 = require('../payments');\nconst psbtutils_2 = require('./psbtutils');\nconst toXOnly = pubKey => (pubKey.length === 32 ? pubKey : pubKey.slice(1, 33));\nexports.toXOnly = toXOnly;\n/**\n * Default tapscript finalizer. It searches for the `tapLeafHashToFinalize` if provided.\n * Otherwise it will search for the tapleaf that has at least one signature and has the shortest path.\n * @param inputIndex the position of the PSBT input.\n * @param input the PSBT input.\n * @param tapLeafHashToFinalize optional, if provided the finalizer will search for a tapleaf that has this hash\n *                              and will try to build the finalScriptWitness.\n * @returns the finalScriptWitness or throws an exception if no tapleaf found.\n */\nfunction tapScriptFinalizer(inputIndex, input, tapLeafHashToFinalize) {\n  const tapLeaf = findTapLeafToFinalize(\n    input,\n    inputIndex,\n    tapLeafHashToFinalize,\n  );\n  try {\n    const sigs = sortSignatures(input, tapLeaf);\n    const witness = sigs.concat(tapLeaf.script).concat(tapLeaf.controlBlock);\n    return {\n      finalScriptWitness: (0, psbtutils_1.witnessStackToScriptWitness)(witness),\n    };\n  } catch (err) {\n    throw new Error(`Can not finalize taproot input #${inputIndex}: ${err}`);\n  }\n}\nexports.tapScriptFinalizer = tapScriptFinalizer;\nfunction serializeTaprootSignature(sig, sighashType) {\n  const sighashTypeByte = sighashType\n    ? Buffer.from([sighashType])\n    : Buffer.from([]);\n  return Buffer.concat([sig, sighashTypeByte]);\n}\nexports.serializeTaprootSignature = serializeTaprootSignature;\nfunction isTaprootInput(input) {\n  return (\n    input &&\n    !!(\n      input.tapInternalKey ||\n      input.tapMerkleRoot ||\n      (input.tapLeafScript && input.tapLeafScript.length) ||\n      (input.tapBip32Derivation && input.tapBip32Derivation.length) ||\n      (input.witnessUtxo && (0, psbtutils_1.isP2TR)(input.witnessUtxo.script))\n    )\n  );\n}\nexports.isTaprootInput = isTaprootInput;\nfunction isTaprootOutput(output, script) {\n  return (\n    output &&\n    !!(\n      output.tapInternalKey ||\n      output.tapTree ||\n      (output.tapBip32Derivation && output.tapBip32Derivation.length) ||\n      (script && (0, psbtutils_1.isP2TR)(script))\n    )\n  );\n}\nexports.isTaprootOutput = isTaprootOutput;\nfunction checkTaprootInputFields(inputData, newInputData, action) {\n  checkMixedTaprootAndNonTaprootInputFields(inputData, newInputData, action);\n  checkIfTapLeafInTree(inputData, newInputData, action);\n}\nexports.checkTaprootInputFields = checkTaprootInputFields;\nfunction checkTaprootOutputFields(outputData, newOutputData, action) {\n  checkMixedTaprootAndNonTaprootOutputFields(outputData, newOutputData, action);\n  checkTaprootScriptPubkey(outputData, newOutputData);\n}\nexports.checkTaprootOutputFields = checkTaprootOutputFields;\nfunction checkTaprootScriptPubkey(outputData, newOutputData) {\n  if (!newOutputData.tapTree && !newOutputData.tapInternalKey) return;\n  const tapInternalKey =\n    newOutputData.tapInternalKey || outputData.tapInternalKey;\n  const tapTree = newOutputData.tapTree || outputData.tapTree;\n  if (tapInternalKey) {\n    const { script: scriptPubkey } = outputData;\n    const script = getTaprootScripPubkey(tapInternalKey, tapTree);\n    if (scriptPubkey && !scriptPubkey.equals(script))\n      throw new Error('Error adding output. Script or address missmatch.');\n  }\n}\nfunction getTaprootScripPubkey(tapInternalKey, tapTree) {\n  const scriptTree = tapTree && tapTreeFromList(tapTree.leaves);\n  const { output } = (0, payments_1.p2tr)({\n    internalPubkey: tapInternalKey,\n    scriptTree,\n  });\n  return output;\n}\nfunction tweakInternalPubKey(inputIndex, input) {\n  const tapInternalKey = input.tapInternalKey;\n  const outputKey =\n    tapInternalKey &&\n    (0, bip341_1.tweakKey)(tapInternalKey, input.tapMerkleRoot);\n  if (!outputKey)\n    throw new Error(\n      `Cannot tweak tap internal key for input #${inputIndex}. Public key: ${\n        tapInternalKey && tapInternalKey.toString('hex')\n      }`,\n    );\n  return outputKey.x;\n}\nexports.tweakInternalPubKey = tweakInternalPubKey;\n/**\n * Convert a binary tree to a BIP371 type list. Each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @param tree the binary tap tree\n * @returns a list of BIP 371 tapleaves\n */\nfunction tapTreeToList(tree) {\n  if (!(0, types_1.isTaptree)(tree))\n    throw new Error(\n      'Cannot convert taptree to tapleaf list. Expecting a tapree structure.',\n    );\n  return _tapTreeToList(tree);\n}\nexports.tapTreeToList = tapTreeToList;\n/**\n * Convert a BIP371 TapLeaf list to a TapTree (binary).\n * @param leaves a list of tapleaves where each element of the list is (according to BIP371):\n * One or more tuples representing the depth, leaf version, and script for a leaf in the Taproot tree,\n * allowing the entire tree to be reconstructed. The tuples must be in depth first search order so that\n * the tree is correctly reconstructed.\n * @returns the corresponding taptree, or throws an exception if the tree cannot be reconstructed\n */\nfunction tapTreeFromList(leaves = []) {\n  if (leaves.length === 1 && leaves[0].depth === 0)\n    return {\n      output: leaves[0].script,\n      version: leaves[0].leafVersion,\n    };\n  return instertLeavesInTree(leaves);\n}\nexports.tapTreeFromList = tapTreeFromList;\nfunction checkTaprootInputForSigs(input, action) {\n  const sigs = extractTaprootSigs(input);\n  return sigs.some(sig =>\n    (0, psbtutils_2.signatureBlocksAction)(sig, decodeSchnorrSignature, action),\n  );\n}\nexports.checkTaprootInputForSigs = checkTaprootInputForSigs;\nfunction decodeSchnorrSignature(signature) {\n  return {\n    signature: signature.slice(0, 64),\n    hashType:\n      signature.slice(64)[0] || transaction_1.Transaction.SIGHASH_DEFAULT,\n  };\n}\nfunction extractTaprootSigs(input) {\n  const sigs = [];\n  if (input.tapKeySig) sigs.push(input.tapKeySig);\n  if (input.tapScriptSig)\n    sigs.push(...input.tapScriptSig.map(s => s.signature));\n  if (!sigs.length) {\n    const finalTapKeySig = getTapKeySigFromWithness(input.finalScriptWitness);\n    if (finalTapKeySig) sigs.push(finalTapKeySig);\n  }\n  return sigs;\n}\nfunction getTapKeySigFromWithness(finalScriptWitness) {\n  if (!finalScriptWitness) return;\n  const witness = finalScriptWitness.slice(2);\n  // todo: add schnorr signature validation\n  if (witness.length === 64 || witness.length === 65) return witness;\n}\nfunction _tapTreeToList(tree, leaves = [], depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (!tree) return [];\n  if ((0, types_1.isTapleaf)(tree)) {\n    leaves.push({\n      depth,\n      leafVersion: tree.version || bip341_1.LEAF_VERSION_TAPSCRIPT,\n      script: tree.output,\n    });\n    return leaves;\n  }\n  if (tree[0]) _tapTreeToList(tree[0], leaves, depth + 1);\n  if (tree[1]) _tapTreeToList(tree[1], leaves, depth + 1);\n  return leaves;\n}\nfunction instertLeavesInTree(leaves) {\n  let tree;\n  for (const leaf of leaves) {\n    tree = instertLeafInTree(leaf, tree);\n    if (!tree) throw new Error(`No room left to insert tapleaf in tree`);\n  }\n  return tree;\n}\nfunction instertLeafInTree(leaf, tree, depth = 0) {\n  if (depth > bip341_1.MAX_TAPTREE_DEPTH)\n    throw new Error('Max taptree depth exceeded.');\n  if (leaf.depth === depth) {\n    if (!tree)\n      return {\n        output: leaf.script,\n        version: leaf.leafVersion,\n      };\n    return;\n  }\n  if ((0, types_1.isTapleaf)(tree)) return;\n  const leftSide = instertLeafInTree(leaf, tree && tree[0], depth + 1);\n  if (leftSide) return [leftSide, tree && tree[1]];\n  const rightSide = instertLeafInTree(leaf, tree && tree[1], depth + 1);\n  if (rightSide) return [tree && tree[0], rightSide];\n}\nfunction checkMixedTaprootAndNonTaprootInputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootInput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootInput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootInput(newInputData) &&\n    hasNonTaprootFields(newInputData); // todo: bad? use !===\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\nfunction checkMixedTaprootAndNonTaprootOutputFields(\n  inputData,\n  newInputData,\n  action,\n) {\n  const isBadTaprootUpdate =\n    isTaprootOutput(inputData) && hasNonTaprootFields(newInputData);\n  const isBadNonTaprootUpdate =\n    hasNonTaprootFields(inputData) && isTaprootOutput(newInputData);\n  const hasMixedFields =\n    inputData === newInputData &&\n    isTaprootOutput(newInputData) &&\n    hasNonTaprootFields(newInputData);\n  if (isBadTaprootUpdate || isBadNonTaprootUpdate || hasMixedFields)\n    throw new Error(\n      `Invalid arguments for Psbt.${action}. ` +\n        `Cannot use both taproot and non-taproot fields.`,\n    );\n}\n/**\n * Checks if the tap leaf is part of the tap tree for the given input data.\n * Throws an error if the tap leaf is not part of the tap tree.\n * @param inputData - The original PsbtInput data.\n * @param newInputData - The new PsbtInput data.\n * @param action - The action being performed.\n * @throws {Error} - If the tap leaf is not part of the tap tree.\n */\nfunction checkIfTapLeafInTree(inputData, newInputData, action) {\n  if (newInputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    const oldLeafsInTree = (inputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, newInputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree || !oldLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  } else if (inputData.tapMerkleRoot) {\n    const newLeafsInTree = (newInputData.tapLeafScript || []).every(l =>\n      isTapLeafInTree(l, inputData.tapMerkleRoot),\n    );\n    if (!newLeafsInTree)\n      throw new Error(\n        `Invalid arguments for Psbt.${action}. Tapleaf not part of taptree.`,\n      );\n  }\n}\n/**\n * Checks if a TapLeafScript is present in a Merkle tree.\n * @param tapLeaf The TapLeafScript to check.\n * @param merkleRoot The Merkle root of the tree. If not provided, the function assumes the TapLeafScript is present.\n * @returns A boolean indicating whether the TapLeafScript is present in the tree.\n */\nfunction isTapLeafInTree(tapLeaf, merkleRoot) {\n  if (!merkleRoot) return true;\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  const rootHash = (0, bip341_1.rootHashFromPath)(\n    tapLeaf.controlBlock,\n    leafHash,\n  );\n  return rootHash.equals(merkleRoot);\n}\n/**\n * Sorts the signatures in the input's tapScriptSig array based on their position in the tapLeaf script.\n *\n * @param input - The PsbtInput object.\n * @param tapLeaf - The TapLeafScript object.\n * @returns An array of sorted signatures as Buffers.\n */\nfunction sortSignatures(input, tapLeaf) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: tapLeaf.script,\n    version: tapLeaf.leafVersion,\n  });\n  return (input.tapScriptSig || [])\n    .filter(tss => tss.leafHash.equals(leafHash))\n    .map(tss => addPubkeyPositionInScript(tapLeaf.script, tss))\n    .sort((t1, t2) => t2.positionInScript - t1.positionInScript)\n    .map(t => t.signature);\n}\n/**\n * Adds the position of a public key in a script to a TapScriptSig object.\n * @param script The script in which to find the position of the public key.\n * @param tss The TapScriptSig object to add the position to.\n * @returns A TapScriptSigWitPosition object with the added position.\n */\nfunction addPubkeyPositionInScript(script, tss) {\n  return Object.assign(\n    {\n      positionInScript: (0, psbtutils_1.pubkeyPositionInScript)(\n        tss.pubkey,\n        script,\n      ),\n    },\n    tss,\n  );\n}\n/**\n * Find tapleaf by hash, or get the signed tapleaf with the shortest path.\n */\nfunction findTapLeafToFinalize(input, inputIndex, leafHashToFinalize) {\n  if (!input.tapScriptSig || !input.tapScriptSig.length)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. No tapleaf script signature provided.`,\n    );\n  const tapLeaf = (input.tapLeafScript || [])\n    .sort((a, b) => a.controlBlock.length - b.controlBlock.length)\n    .find(leaf =>\n      canFinalizeLeaf(leaf, input.tapScriptSig, leafHashToFinalize),\n    );\n  if (!tapLeaf)\n    throw new Error(\n      `Can not finalize taproot input #${inputIndex}. Signature for tapleaf script not found.`,\n    );\n  return tapLeaf;\n}\n/**\n * Determines whether a TapLeafScript can be finalized.\n *\n * @param leaf - The TapLeafScript to check.\n * @param tapScriptSig - The array of TapScriptSig objects.\n * @param hash - The optional hash to compare with the leaf hash.\n * @returns A boolean indicating whether the TapLeafScript can be finalized.\n */\nfunction canFinalizeLeaf(leaf, tapScriptSig, hash) {\n  const leafHash = (0, bip341_1.tapleafHash)({\n    output: leaf.script,\n    version: leaf.leafVersion,\n  });\n  const whiteListedHash = !hash || hash.equals(leafHash);\n  return (\n    whiteListedHash &&\n    tapScriptSig.find(tss => tss.leafHash.equals(leafHash)) !== undefined\n  );\n}\n/**\n * Checks if the given PsbtInput or PsbtOutput has non-taproot fields.\n * Non-taproot fields include redeemScript, witnessScript, and bip32Derivation.\n * @param io The PsbtInput or PsbtOutput to check.\n * @returns A boolean indicating whether the given input or output has non-taproot fields.\n */\nfunction hasNonTaprootFields(io) {\n  return (\n    io &&\n    !!(\n      io.redeemScript ||\n      io.witnessScript ||\n      (io.bip32Derivation && io.bip32Derivation.length)\n    )\n  );\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.Psbt = void 0;\nconst bip174_1 = require('bip174');\nconst varuint = require('bip174/src/lib/converter/varint');\nconst utils_1 = require('bip174/src/lib/utils');\nconst address_1 = require('./address');\nconst bufferutils_1 = require('./bufferutils');\nconst networks_1 = require('./networks');\nconst payments = require('./payments');\nconst bip341_1 = require('./payments/bip341');\nconst bscript = require('./script');\nconst transaction_1 = require('./transaction');\nconst bip371_1 = require('./psbt/bip371');\nconst psbtutils_1 = require('./psbt/psbtutils');\n/**\n * These are the default arguments for a Psbt instance.\n */\nconst DEFAULT_OPTS = {\n  /**\n   * A bitcoinjs Network object. This is only used if you pass an `address`\n   * parameter to addOutput. Otherwise it is not needed and can be left default.\n   */\n  network: networks_1.bitcoin,\n  /**\n   * When extractTransaction is called, the fee rate is checked.\n   * THIS IS NOT TO BE RELIED ON.\n   * It is only here as a last ditch effort to prevent sending a 500 BTC fee etc.\n   */\n  maximumFeeRate: 5000, // satoshi per byte\n};\n/**\n * Psbt class can parse and generate a PSBT binary based off of the BIP174.\n * There are 6 roles that this class fulfills. (Explained in BIP174)\n *\n * Creator: This can be done with `new Psbt()`\n *\n * Updater: This can be done with `psbt.addInput(input)`, `psbt.addInputs(inputs)`,\n *   `psbt.addOutput(output)`, `psbt.addOutputs(outputs)` when you are looking to\n *   add new inputs and outputs to the PSBT, and `psbt.updateGlobal(itemObject)`,\n *   `psbt.updateInput(itemObject)`, `psbt.updateOutput(itemObject)`\n *   addInput requires hash: Buffer | string; and index: number; as attributes\n *   and can also include any attributes that are used in updateInput method.\n *   addOutput requires script: Buffer; and value: number; and likewise can include\n *   data for updateOutput.\n *   For a list of what attributes should be what types. Check the bip174 library.\n *   Also, check the integration tests for some examples of usage.\n *\n * Signer: There are a few methods. signAllInputs and signAllInputsAsync, which will search all input\n *   information for your pubkey or pubkeyhash, and only sign inputs where it finds\n *   your info. Or you can explicitly sign a specific input with signInput and\n *   signInputAsync. For the async methods you can create a SignerAsync object\n *   and use something like a hardware wallet to sign with. (You must implement this)\n *\n * Combiner: psbts can be combined easily with `psbt.combine(psbt2, psbt3, psbt4 ...)`\n *   the psbt calling combine will always have precedence when a conflict occurs.\n *   Combine checks if the internal bitcoin transaction is the same, so be sure that\n *   all sequences, version, locktime, etc. are the same before combining.\n *\n * Input Finalizer: This role is fairly important. Not only does it need to construct\n *   the input scriptSigs and witnesses, but it SHOULD verify the signatures etc.\n *   Before running `psbt.finalizeAllInputs()` please run `psbt.validateSignaturesOfAllInputs()`\n *   Running any finalize method will delete any data in the input(s) that are no longer\n *   needed due to the finalized scripts containing the information.\n *\n * Transaction Extractor: This role will perform some checks before returning a\n *   Transaction object. Such as fee rate not being larger than maximumFeeRate etc.\n */\nclass Psbt {\n  static fromBase64(data, opts = {}) {\n    const buffer = Buffer.from(data, 'base64');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromHex(data, opts = {}) {\n    const buffer = Buffer.from(data, 'hex');\n    return this.fromBuffer(buffer, opts);\n  }\n  static fromBuffer(buffer, opts = {}) {\n    const psbtBase = bip174_1.Psbt.fromBuffer(buffer, transactionFromBuffer);\n    const psbt = new Psbt(opts, psbtBase);\n    checkTxForDupeIns(psbt.__CACHE.__TX, psbt.__CACHE);\n    return psbt;\n  }\n  constructor(opts = {}, data = new bip174_1.Psbt(new PsbtTransaction())) {\n    this.data = data;\n    // set defaults\n    this.opts = Object.assign({}, DEFAULT_OPTS, opts);\n    this.__CACHE = {\n      __NON_WITNESS_UTXO_TX_CACHE: [],\n      __NON_WITNESS_UTXO_BUF_CACHE: [],\n      __TX_IN_CACHE: {},\n      __TX: this.data.globalMap.unsignedTx.tx,\n      // Psbt's predecessor (TransactionBuilder - now removed) behavior\n      // was to not confirm input values  before signing.\n      // Even though we highly encourage people to get\n      // the full parent transaction to verify values, the ability to\n      // sign non-segwit inputs without the full transaction was often\n      // requested. So the only way to activate is to use @ts-ignore.\n      // We will disable exporting the Psbt when unsafe sign is active.\n      // because it is not BIP174 compliant.\n      __UNSAFE_SIGN_NONSEGWIT: false,\n    };\n    if (this.data.inputs.length === 0) this.setVersion(2);\n    // Make data hidden when enumerating\n    const dpew = (obj, attr, enumerable, writable) =>\n      Object.defineProperty(obj, attr, {\n        enumerable,\n        writable,\n      });\n    dpew(this, '__CACHE', false, true);\n    dpew(this, 'opts', false, true);\n  }\n  get inputCount() {\n    return this.data.inputs.length;\n  }\n  get version() {\n    return this.__CACHE.__TX.version;\n  }\n  set version(version) {\n    this.setVersion(version);\n  }\n  get locktime() {\n    return this.__CACHE.__TX.locktime;\n  }\n  set locktime(locktime) {\n    this.setLocktime(locktime);\n  }\n  get txInputs() {\n    return this.__CACHE.__TX.ins.map(input => ({\n      hash: (0, bufferutils_1.cloneBuffer)(input.hash),\n      index: input.index,\n      sequence: input.sequence,\n    }));\n  }\n  get txOutputs() {\n    return this.__CACHE.__TX.outs.map(output => {\n      let address;\n      try {\n        address = (0, address_1.fromOutputScript)(\n          output.script,\n          this.opts.network,\n        );\n      } catch (_) {}\n      return {\n        script: (0, bufferutils_1.cloneBuffer)(output.script),\n        value: output.value,\n        address,\n      };\n    });\n  }\n  combine(...those) {\n    this.data.combine(...those.map(o => o.data));\n    return this;\n  }\n  clone() {\n    // TODO: more efficient cloning\n    const res = Psbt.fromBuffer(this.data.toBuffer());\n    res.opts = JSON.parse(JSON.stringify(this.opts));\n    return res;\n  }\n  setMaximumFeeRate(satoshiPerByte) {\n    check32Bit(satoshiPerByte); // 42.9 BTC per byte IS excessive... so throw\n    this.opts.maximumFeeRate = satoshiPerByte;\n  }\n  setVersion(version) {\n    check32Bit(version);\n    checkInputsForPartialSig(this.data.inputs, 'setVersion');\n    const c = this.__CACHE;\n    c.__TX.version = version;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setLocktime(locktime) {\n    check32Bit(locktime);\n    checkInputsForPartialSig(this.data.inputs, 'setLocktime');\n    const c = this.__CACHE;\n    c.__TX.locktime = locktime;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  setInputSequence(inputIndex, sequence) {\n    check32Bit(sequence);\n    checkInputsForPartialSig(this.data.inputs, 'setInputSequence');\n    const c = this.__CACHE;\n    if (c.__TX.ins.length <= inputIndex) {\n      throw new Error('Input index too high');\n    }\n    c.__TX.ins[inputIndex].sequence = sequence;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addInputs(inputDatas) {\n    inputDatas.forEach(inputData => this.addInput(inputData));\n    return this;\n  }\n  addInput(inputData) {\n    if (\n      arguments.length > 1 ||\n      !inputData ||\n      inputData.hash === undefined ||\n      inputData.index === undefined\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addInput. ` +\n          `Requires single object with at least [hash] and [index]`,\n      );\n    }\n    (0, bip371_1.checkTaprootInputFields)(inputData, inputData, 'addInput');\n    checkInputsForPartialSig(this.data.inputs, 'addInput');\n    if (inputData.witnessScript) checkInvalidP2WSH(inputData.witnessScript);\n    const c = this.__CACHE;\n    this.data.addInput(inputData);\n    const txIn = c.__TX.ins[c.__TX.ins.length - 1];\n    checkTxInputCache(c, txIn);\n    const inputIndex = this.data.inputs.length - 1;\n    const input = this.data.inputs[inputIndex];\n    if (input.nonWitnessUtxo) {\n      addNonWitnessTxCache(this.__CACHE, input, inputIndex);\n    }\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  addOutputs(outputDatas) {\n    outputDatas.forEach(outputData => this.addOutput(outputData));\n    return this;\n  }\n  addOutput(outputData) {\n    if (\n      arguments.length > 1 ||\n      !outputData ||\n      outputData.value === undefined ||\n      (outputData.address === undefined && outputData.script === undefined)\n    ) {\n      throw new Error(\n        `Invalid arguments for Psbt.addOutput. ` +\n          `Requires single object with at least [script or address] and [value]`,\n      );\n    }\n    checkInputsForPartialSig(this.data.inputs, 'addOutput');\n    const { address } = outputData;\n    if (typeof address === 'string') {\n      const { network } = this.opts;\n      const script = (0, address_1.toOutputScript)(address, network);\n      outputData = Object.assign({}, outputData, { script });\n    }\n    (0, bip371_1.checkTaprootOutputFields)(outputData, outputData, 'addOutput');\n    const c = this.__CACHE;\n    this.data.addOutput(outputData);\n    c.__FEE = undefined;\n    c.__FEE_RATE = undefined;\n    c.__EXTRACTED_TX = undefined;\n    return this;\n  }\n  extractTransaction(disableFeeCheck) {\n    if (!this.data.inputs.every(isFinalized)) throw new Error('Not finalized');\n    const c = this.__CACHE;\n    if (!disableFeeCheck) {\n      checkFees(this, c, this.opts);\n    }\n    if (c.__EXTRACTED_TX) return c.__EXTRACTED_TX;\n    const tx = c.__TX.clone();\n    inputFinalizeGetAmts(this.data.inputs, tx, c, true);\n    return tx;\n  }\n  getFeeRate() {\n    return getTxCacheValue(\n      '__FEE_RATE',\n      'fee rate',\n      this.data.inputs,\n      this.__CACHE,\n    );\n  }\n  getFee() {\n    return getTxCacheValue('__FEE', 'fee', this.data.inputs, this.__CACHE);\n  }\n  finalizeAllInputs() {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    range(this.data.inputs.length).forEach(idx => this.finalizeInput(idx));\n    return this;\n  }\n  finalizeInput(inputIndex, finalScriptsFunc) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        undefined,\n        finalScriptsFunc,\n      );\n    return this._finalizeInput(inputIndex, input, finalScriptsFunc);\n  }\n  finalizeTaprootInput(\n    inputIndex,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._finalizeTaprootInput(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n        finalScriptsFunc,\n      );\n    throw new Error(`Cannot finalize input #${inputIndex}. Not Taproot.`);\n  }\n  _finalizeInput(inputIndex, input, finalScriptsFunc = getFinalScripts) {\n    const { script, isP2SH, isP2WSH, isSegwit } = getScriptFromInput(\n      inputIndex,\n      input,\n      this.__CACHE,\n    );\n    if (!script) throw new Error(`No script found for input #${inputIndex}`);\n    checkPartialSigSighashes(input);\n    const { finalScriptSig, finalScriptWitness } = finalScriptsFunc(\n      inputIndex,\n      input,\n      script,\n      isSegwit,\n      isP2SH,\n      isP2WSH,\n    );\n    if (finalScriptSig) this.data.updateInput(inputIndex, { finalScriptSig });\n    if (finalScriptWitness)\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    if (!finalScriptSig && !finalScriptWitness)\n      throw new Error(`Unknown error finalizing input #${inputIndex}`);\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  _finalizeTaprootInput(\n    inputIndex,\n    input,\n    tapLeafHashToFinalize,\n    finalScriptsFunc = bip371_1.tapScriptFinalizer,\n  ) {\n    if (!input.witnessUtxo)\n      throw new Error(\n        `Cannot finalize input #${inputIndex}. Missing withness utxo.`,\n      );\n    // Check key spend first. Increased privacy and reduced block space.\n    if (input.tapKeySig) {\n      const payment = payments.p2tr({\n        output: input.witnessUtxo.script,\n        signature: input.tapKeySig,\n      });\n      const finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    } else {\n      const { finalScriptWitness } = finalScriptsFunc(\n        inputIndex,\n        input,\n        tapLeafHashToFinalize,\n      );\n      this.data.updateInput(inputIndex, { finalScriptWitness });\n    }\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n  getInputType(inputIndex) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const script = getScriptFromUtxo(inputIndex, input, this.__CACHE);\n    const result = getMeaningfulScript(\n      script,\n      inputIndex,\n      'input',\n      input.redeemScript || redeemFromFinalScriptSig(input.finalScriptSig),\n      input.witnessScript ||\n        redeemFromFinalWitnessScript(input.finalScriptWitness),\n    );\n    const type = result.type === 'raw' ? '' : result.type + '-';\n    const mainType = classifyScript(result.meaningfulScript);\n    return type + mainType;\n  }\n  inputHasPubkey(inputIndex, pubkey) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    return pubkeyInInput(pubkey, input, inputIndex, this.__CACHE);\n  }\n  inputHasHDKey(inputIndex, root) {\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!input.bip32Derivation && input.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  outputHasPubkey(outputIndex, pubkey) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    return pubkeyInOutput(pubkey, output, outputIndex, this.__CACHE);\n  }\n  outputHasHDKey(outputIndex, root) {\n    const output = (0, utils_1.checkForOutput)(this.data.outputs, outputIndex);\n    const derivationIsMine = bip32DerivationIsMine(root);\n    return (\n      !!output.bip32Derivation && output.bip32Derivation.some(derivationIsMine)\n    );\n  }\n  validateSignaturesOfAllInputs(validator) {\n    (0, utils_1.checkForInput)(this.data.inputs, 0); // making sure we have at least one\n    const results = range(this.data.inputs.length).map(idx =>\n      this.validateSignaturesOfInput(idx, validator),\n    );\n    return results.reduce((final, res) => res === true && final, true);\n  }\n  validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this.validateSignaturesOfTaprootInput(\n        inputIndex,\n        validator,\n        pubkey,\n      );\n    return this._validateSignaturesOfInput(inputIndex, validator, pubkey);\n  }\n  _validateSignaturesOfInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const partialSig = (input || {}).partialSig;\n    if (!input || !partialSig || partialSig.length < 1)\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    const mySigs = pubkey\n      ? partialSig.filter(sig => sig.pubkey.equals(pubkey))\n      : partialSig;\n    if (mySigs.length < 1) throw new Error('No signatures for this pubkey');\n    const results = [];\n    let hashCache;\n    let scriptCache;\n    let sighashCache;\n    for (const pSig of mySigs) {\n      const sig = bscript.signature.decode(pSig.signature);\n      const { hash, script } =\n        sighashCache !== sig.hashType\n          ? getHashForSig(\n              inputIndex,\n              Object.assign({}, input, { sighashType: sig.hashType }),\n              this.__CACHE,\n              true,\n            )\n          : { hash: hashCache, script: scriptCache };\n      sighashCache = sig.hashType;\n      hashCache = hash;\n      scriptCache = script;\n      checkScriptForPubkey(pSig.pubkey, script, 'verify');\n      results.push(validator(pSig.pubkey, hash, sig.signature));\n    }\n    return results.every(res => res === true);\n  }\n  validateSignaturesOfTaprootInput(inputIndex, validator, pubkey) {\n    const input = this.data.inputs[inputIndex];\n    const tapKeySig = (input || {}).tapKeySig;\n    const tapScriptSig = (input || {}).tapScriptSig;\n    if (!input && !tapKeySig && !(tapScriptSig && !tapScriptSig.length))\n      throw new Error('No signatures to validate');\n    if (typeof validator !== 'function')\n      throw new Error('Need validator function to validate signatures');\n    pubkey = pubkey && (0, bip371_1.toXOnly)(pubkey);\n    const allHashses = pubkey\n      ? getTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          pubkey,\n          this.__CACHE,\n        )\n      : getAllTaprootHashesForSig(\n          inputIndex,\n          input,\n          this.data.inputs,\n          this.__CACHE,\n        );\n    if (!allHashses.length) throw new Error('No signatures for this pubkey');\n    const tapKeyHash = allHashses.find(h => !h.leafHash);\n    let validationResultCount = 0;\n    if (tapKeySig && tapKeyHash) {\n      const isValidTapkeySig = validator(\n        tapKeyHash.pubkey,\n        tapKeyHash.hash,\n        trimTaprootSig(tapKeySig),\n      );\n      if (!isValidTapkeySig) return false;\n      validationResultCount++;\n    }\n    if (tapScriptSig) {\n      for (const tapSig of tapScriptSig) {\n        const tapSigHash = allHashses.find(h => tapSig.pubkey.equals(h.pubkey));\n        if (tapSigHash) {\n          const isValidTapScriptSig = validator(\n            tapSig.pubkey,\n            tapSigHash.hash,\n            trimTaprootSig(tapSig.signature),\n          );\n          if (!isValidTapScriptSig) return false;\n          validationResultCount++;\n        }\n      }\n    }\n    return validationResultCount > 0;\n  }\n  signAllInputsHD(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInputHD(i, hdKeyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsHDAsync(\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const results = [];\n      const promises = [];\n      for (const i of range(this.data.inputs.length)) {\n        promises.push(\n          this.signInputHDAsync(i, hdKeyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInputHD(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n      throw new Error('Need HDSigner to sign input');\n    }\n    const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n    signers.forEach(signer => this.signInput(inputIndex, signer, sighashTypes));\n    return this;\n  }\n  signInputHDAsync(\n    inputIndex,\n    hdKeyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    return new Promise((resolve, reject) => {\n      if (!hdKeyPair || !hdKeyPair.publicKey || !hdKeyPair.fingerprint) {\n        return reject(new Error('Need HDSigner to sign input'));\n      }\n      const signers = getSignersFromHD(inputIndex, this.data.inputs, hdKeyPair);\n      const promises = signers.map(signer =>\n        this.signInputAsync(inputIndex, signer, sighashTypes),\n      );\n      return Promise.all(promises)\n        .then(() => {\n          resolve();\n        })\n        .catch(reject);\n    });\n  }\n  signAllInputs(keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    // TODO: Add a pubkey/pubkeyhash cache to each input\n    // as input information is added, then eventually\n    // optimize this method.\n    const results = [];\n    for (const i of range(this.data.inputs.length)) {\n      try {\n        this.signInput(i, keyPair, sighashTypes);\n        results.push(true);\n      } catch (err) {\n        results.push(false);\n      }\n    }\n    if (results.every(v => v === false)) {\n      throw new Error('No inputs were signed');\n    }\n    return this;\n  }\n  signAllInputsAsync(keyPair, sighashTypes) {\n    return new Promise((resolve, reject) => {\n      if (!keyPair || !keyPair.publicKey)\n        return reject(new Error('Need Signer to sign input'));\n      // TODO: Add a pubkey/pubkeyhash cache to each input\n      // as input information is added, then eventually\n      // optimize this method.\n      const results = [];\n      const promises = [];\n      for (const [i] of this.data.inputs.entries()) {\n        promises.push(\n          this.signInputAsync(i, keyPair, sighashTypes).then(\n            () => {\n              results.push(true);\n            },\n            () => {\n              results.push(false);\n            },\n          ),\n        );\n      }\n      return Promise.all(promises).then(() => {\n        if (results.every(v => v === false)) {\n          return reject(new Error('No inputs were signed'));\n        }\n        resolve();\n      });\n    });\n  }\n  signInput(inputIndex, keyPair, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input)) {\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        undefined,\n        sighashTypes,\n      );\n    }\n    return this._signInput(inputIndex, keyPair, sighashTypes);\n  }\n  signTaprootInput(inputIndex, keyPair, tapLeafHashToSign, sighashTypes) {\n    if (!keyPair || !keyPair.publicKey)\n      throw new Error('Need Signer to sign input');\n    const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n    if ((0, bip371_1.isTaprootInput)(input))\n      return this._signTaprootInput(\n        inputIndex,\n        input,\n        keyPair,\n        tapLeafHashToSign,\n        sighashTypes,\n      );\n    throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n  }\n  _signInput(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    const partialSig = [\n      {\n        pubkey: keyPair.publicKey,\n        signature: bscript.signature.encode(keyPair.sign(hash), sighashType),\n      },\n    ];\n    this.data.updateInput(inputIndex, { partialSig });\n    return this;\n  }\n  _signTaprootInput(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    const tapKeySig = hashesForSig\n      .filter(h => !h.leafHash)\n      .map(h =>\n        (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n      )[0];\n    const tapScriptSig = hashesForSig\n      .filter(h => !!h.leafHash)\n      .map(h => ({\n        pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n        signature: (0, bip371_1.serializeTaprootSignature)(\n          keyPair.signSchnorr(h.hash),\n          input.sighashType,\n        ),\n        leafHash: h.leafHash,\n      }));\n    if (tapKeySig) {\n      this.data.updateInput(inputIndex, { tapKeySig });\n    }\n    if (tapScriptSig.length) {\n      this.data.updateInput(inputIndex, { tapScriptSig });\n    }\n    return this;\n  }\n  signInputAsync(inputIndex, keyPair, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          undefined,\n          sighashTypes,\n        );\n      return this._signInputAsync(inputIndex, keyPair, sighashTypes);\n    });\n  }\n  signTaprootInputAsync(inputIndex, keyPair, tapLeafHash, sighashTypes) {\n    return Promise.resolve().then(() => {\n      if (!keyPair || !keyPair.publicKey)\n        throw new Error('Need Signer to sign input');\n      const input = (0, utils_1.checkForInput)(this.data.inputs, inputIndex);\n      if ((0, bip371_1.isTaprootInput)(input))\n        return this._signTaprootInputAsync(\n          inputIndex,\n          input,\n          keyPair,\n          tapLeafHash,\n          sighashTypes,\n        );\n      throw new Error(`Input #${inputIndex} is not of type Taproot.`);\n    });\n  }\n  _signInputAsync(\n    inputIndex,\n    keyPair,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_ALL],\n  ) {\n    const { hash, sighashType } = getHashAndSighashType(\n      this.data.inputs,\n      inputIndex,\n      keyPair.publicKey,\n      this.__CACHE,\n      sighashTypes,\n    );\n    return Promise.resolve(keyPair.sign(hash)).then(signature => {\n      const partialSig = [\n        {\n          pubkey: keyPair.publicKey,\n          signature: bscript.signature.encode(signature, sighashType),\n        },\n      ];\n      this.data.updateInput(inputIndex, { partialSig });\n    });\n  }\n  async _signTaprootInputAsync(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHash,\n    sighashTypes = [transaction_1.Transaction.SIGHASH_DEFAULT],\n  ) {\n    const hashesForSig = this.checkTaprootHashesForSig(\n      inputIndex,\n      input,\n      keyPair,\n      tapLeafHash,\n      sighashTypes,\n    );\n    const signaturePromises = [];\n    const tapKeyHash = hashesForSig.filter(h => !h.leafHash)[0];\n    if (tapKeyHash) {\n      const tapKeySigPromise = Promise.resolve(\n        keyPair.signSchnorr(tapKeyHash.hash),\n      ).then(sig => {\n        return {\n          tapKeySig: (0, bip371_1.serializeTaprootSignature)(\n            sig,\n            input.sighashType,\n          ),\n        };\n      });\n      signaturePromises.push(tapKeySigPromise);\n    }\n    const tapScriptHashes = hashesForSig.filter(h => !!h.leafHash);\n    if (tapScriptHashes.length) {\n      const tapScriptSigPromises = tapScriptHashes.map(tsh => {\n        return Promise.resolve(keyPair.signSchnorr(tsh.hash)).then(\n          signature => {\n            const tapScriptSig = [\n              {\n                pubkey: (0, bip371_1.toXOnly)(keyPair.publicKey),\n                signature: (0, bip371_1.serializeTaprootSignature)(\n                  signature,\n                  input.sighashType,\n                ),\n                leafHash: tsh.leafHash,\n              },\n            ];\n            return { tapScriptSig };\n          },\n        );\n      });\n      signaturePromises.push(...tapScriptSigPromises);\n    }\n    return Promise.all(signaturePromises).then(results => {\n      results.forEach(v => this.data.updateInput(inputIndex, v));\n    });\n  }\n  checkTaprootHashesForSig(\n    inputIndex,\n    input,\n    keyPair,\n    tapLeafHashToSign,\n    allowedSighashTypes,\n  ) {\n    if (typeof keyPair.signSchnorr !== 'function')\n      throw new Error(\n        `Need Schnorr Signer to sign taproot input #${inputIndex}.`,\n      );\n    const hashesForSig = getTaprootHashesForSig(\n      inputIndex,\n      input,\n      this.data.inputs,\n      keyPair.publicKey,\n      this.__CACHE,\n      tapLeafHashToSign,\n      allowedSighashTypes,\n    );\n    if (!hashesForSig || !hashesForSig.length)\n      throw new Error(\n        `Can not sign for input #${inputIndex} with the key ${keyPair.publicKey.toString(\n          'hex',\n        )}`,\n      );\n    return hashesForSig;\n  }\n  toBuffer() {\n    checkCache(this.__CACHE);\n    return this.data.toBuffer();\n  }\n  toHex() {\n    checkCache(this.__CACHE);\n    return this.data.toHex();\n  }\n  toBase64() {\n    checkCache(this.__CACHE);\n    return this.data.toBase64();\n  }\n  updateGlobal(updateData) {\n    this.data.updateGlobal(updateData);\n    return this;\n  }\n  updateInput(inputIndex, updateData) {\n    if (updateData.witnessScript) checkInvalidP2WSH(updateData.witnessScript);\n    (0, bip371_1.checkTaprootInputFields)(\n      this.data.inputs[inputIndex],\n      updateData,\n      'updateInput',\n    );\n    this.data.updateInput(inputIndex, updateData);\n    if (updateData.nonWitnessUtxo) {\n      addNonWitnessTxCache(\n        this.__CACHE,\n        this.data.inputs[inputIndex],\n        inputIndex,\n      );\n    }\n    return this;\n  }\n  updateOutput(outputIndex, updateData) {\n    const outputData = this.data.outputs[outputIndex];\n    (0, bip371_1.checkTaprootOutputFields)(\n      outputData,\n      updateData,\n      'updateOutput',\n    );\n    this.data.updateOutput(outputIndex, updateData);\n    return this;\n  }\n  addUnknownKeyValToGlobal(keyVal) {\n    this.data.addUnknownKeyValToGlobal(keyVal);\n    return this;\n  }\n  addUnknownKeyValToInput(inputIndex, keyVal) {\n    this.data.addUnknownKeyValToInput(inputIndex, keyVal);\n    return this;\n  }\n  addUnknownKeyValToOutput(outputIndex, keyVal) {\n    this.data.addUnknownKeyValToOutput(outputIndex, keyVal);\n    return this;\n  }\n  clearFinalizedInput(inputIndex) {\n    this.data.clearFinalizedInput(inputIndex);\n    return this;\n  }\n}\nexports.Psbt = Psbt;\n/**\n * This function is needed to pass to the bip174 base class's fromBuffer.\n * It takes the \"transaction buffer\" portion of the psbt buffer and returns a\n * Transaction (From the bip174 library) interface.\n */\nconst transactionFromBuffer = buffer => new PsbtTransaction(buffer);\n/**\n * This class implements the Transaction interface from bip174 library.\n * It contains a bitcoinjs-lib Transaction object.\n */\nclass PsbtTransaction {\n  constructor(buffer = Buffer.from([2, 0, 0, 0, 0, 0, 0, 0, 0, 0])) {\n    this.tx = transaction_1.Transaction.fromBuffer(buffer);\n    checkTxEmpty(this.tx);\n    Object.defineProperty(this, 'tx', {\n      enumerable: false,\n      writable: true,\n    });\n  }\n  getInputOutputCounts() {\n    return {\n      inputCount: this.tx.ins.length,\n      outputCount: this.tx.outs.length,\n    };\n  }\n  addInput(input) {\n    if (\n      input.hash === undefined ||\n      input.index === undefined ||\n      (!Buffer.isBuffer(input.hash) && typeof input.hash !== 'string') ||\n      typeof input.index !== 'number'\n    ) {\n      throw new Error('Error adding input.');\n    }\n    const hash =\n      typeof input.hash === 'string'\n        ? (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash, 'hex'))\n        : input.hash;\n    this.tx.addInput(hash, input.index, input.sequence);\n  }\n  addOutput(output) {\n    if (\n      output.script === undefined ||\n      output.value === undefined ||\n      !Buffer.isBuffer(output.script) ||\n      typeof output.value !== 'number'\n    ) {\n      throw new Error('Error adding output.');\n    }\n    this.tx.addOutput(output.script, output.value);\n  }\n  toBuffer() {\n    return this.tx.toBuffer();\n  }\n}\nfunction canFinalize(input, script, scriptType) {\n  switch (scriptType) {\n    case 'pubkey':\n    case 'pubkeyhash':\n    case 'witnesspubkeyhash':\n      return hasSigs(1, input.partialSig);\n    case 'multisig':\n      const p2ms = payments.p2ms({ output: script });\n      return hasSigs(p2ms.m, input.partialSig, p2ms.pubkeys);\n    default:\n      return false;\n  }\n}\nfunction checkCache(cache) {\n  if (cache.__UNSAFE_SIGN_NONSEGWIT !== false) {\n    throw new Error('Not BIP174 compliant, can not export');\n  }\n}\nfunction hasSigs(neededSigs, partialSig, pubkeys) {\n  if (!partialSig) return false;\n  let sigs;\n  if (pubkeys) {\n    sigs = pubkeys\n      .map(pkey => {\n        const pubkey = compressPubkey(pkey);\n        return partialSig.find(pSig => pSig.pubkey.equals(pubkey));\n      })\n      .filter(v => !!v);\n  } else {\n    sigs = partialSig;\n  }\n  if (sigs.length > neededSigs) throw new Error('Too many signatures');\n  return sigs.length === neededSigs;\n}\nfunction isFinalized(input) {\n  return !!input.finalScriptSig || !!input.finalScriptWitness;\n}\nfunction bip32DerivationIsMine(root) {\n  return d => {\n    if (!d.masterFingerprint.equals(root.fingerprint)) return false;\n    if (!root.derivePath(d.path).publicKey.equals(d.pubkey)) return false;\n    return true;\n  };\n}\nfunction check32Bit(num) {\n  if (\n    typeof num !== 'number' ||\n    num !== Math.floor(num) ||\n    num > 0xffffffff ||\n    num < 0\n  ) {\n    throw new Error('Invalid 32 bit integer');\n  }\n}\nfunction checkFees(psbt, cache, opts) {\n  const feeRate = cache.__FEE_RATE || psbt.getFeeRate();\n  const vsize = cache.__EXTRACTED_TX.virtualSize();\n  const satoshis = feeRate * vsize;\n  if (feeRate >= opts.maximumFeeRate) {\n    throw new Error(\n      `Warning: You are paying around ${(satoshis / 1e8).toFixed(8)} in ` +\n        `fees, which is ${feeRate} satoshi per byte for a transaction ` +\n        `with a VSize of ${vsize} bytes (segwit counted as 0.25 byte per ` +\n        `byte). Use setMaximumFeeRate method to raise your threshold, or ` +\n        `pass true to the first arg of extractTransaction.`,\n    );\n  }\n}\nfunction checkInputsForPartialSig(inputs, action) {\n  inputs.forEach(input => {\n    const throws = (0, bip371_1.isTaprootInput)(input)\n      ? (0, bip371_1.checkTaprootInputForSigs)(input, action)\n      : (0, psbtutils_1.checkInputForSig)(input, action);\n    if (throws)\n      throw new Error('Can not modify transaction, signatures exist.');\n  });\n}\nfunction checkPartialSigSighashes(input) {\n  if (!input.sighashType || !input.partialSig) return;\n  const { partialSig, sighashType } = input;\n  partialSig.forEach(pSig => {\n    const { hashType } = bscript.signature.decode(pSig.signature);\n    if (sighashType !== hashType) {\n      throw new Error('Signature sighash does not match input sighash type');\n    }\n  });\n}\nfunction checkScriptForPubkey(pubkey, script, action) {\n  if (!(0, psbtutils_1.pubkeyInScript)(pubkey, script)) {\n    throw new Error(\n      `Can not ${action} for this input with the key ${pubkey.toString('hex')}`,\n    );\n  }\n}\nfunction checkTxEmpty(tx) {\n  const isEmpty = tx.ins.every(\n    input =>\n      input.script &&\n      input.script.length === 0 &&\n      input.witness &&\n      input.witness.length === 0,\n  );\n  if (!isEmpty) {\n    throw new Error('Format Error: Transaction ScriptSigs are not empty');\n  }\n}\nfunction checkTxForDupeIns(tx, cache) {\n  tx.ins.forEach(input => {\n    checkTxInputCache(cache, input);\n  });\n}\nfunction checkTxInputCache(cache, input) {\n  const key =\n    (0, bufferutils_1.reverseBuffer)(Buffer.from(input.hash)).toString('hex') +\n    ':' +\n    input.index;\n  if (cache.__TX_IN_CACHE[key]) throw new Error('Duplicate input detected.');\n  cache.__TX_IN_CACHE[key] = 1;\n}\nfunction scriptCheckerFactory(payment, paymentScriptName) {\n  return (inputIndex, scriptPubKey, redeemScript, ioType) => {\n    const redeemScriptOutput = payment({\n      redeem: { output: redeemScript },\n    }).output;\n    if (!scriptPubKey.equals(redeemScriptOutput)) {\n      throw new Error(\n        `${paymentScriptName} for ${ioType} #${inputIndex} doesn't match the scriptPubKey in the prevout`,\n      );\n    }\n  };\n}\nconst checkRedeemScript = scriptCheckerFactory(payments.p2sh, 'Redeem script');\nconst checkWitnessScript = scriptCheckerFactory(\n  payments.p2wsh,\n  'Witness script',\n);\nfunction getTxCacheValue(key, name, inputs, c) {\n  if (!inputs.every(isFinalized))\n    throw new Error(`PSBT must be finalized to calculate ${name}`);\n  if (key === '__FEE_RATE' && c.__FEE_RATE) return c.__FEE_RATE;\n  if (key === '__FEE' && c.__FEE) return c.__FEE;\n  let tx;\n  let mustFinalize = true;\n  if (c.__EXTRACTED_TX) {\n    tx = c.__EXTRACTED_TX;\n    mustFinalize = false;\n  } else {\n    tx = c.__TX.clone();\n  }\n  inputFinalizeGetAmts(inputs, tx, c, mustFinalize);\n  if (key === '__FEE_RATE') return c.__FEE_RATE;\n  else if (key === '__FEE') return c.__FEE;\n}\nfunction getFinalScripts(inputIndex, input, script, isSegwit, isP2SH, isP2WSH) {\n  const scriptType = classifyScript(script);\n  if (!canFinalize(input, script, scriptType))\n    throw new Error(`Can not finalize input #${inputIndex}`);\n  return prepareFinalScripts(\n    script,\n    scriptType,\n    input.partialSig,\n    isSegwit,\n    isP2SH,\n    isP2WSH,\n  );\n}\nfunction prepareFinalScripts(\n  script,\n  scriptType,\n  partialSig,\n  isSegwit,\n  isP2SH,\n  isP2WSH,\n) {\n  let finalScriptSig;\n  let finalScriptWitness;\n  // Wow, the payments API is very handy\n  const payment = getPayment(script, scriptType, partialSig);\n  const p2wsh = !isP2WSH ? null : payments.p2wsh({ redeem: payment });\n  const p2sh = !isP2SH ? null : payments.p2sh({ redeem: p2wsh || payment });\n  if (isSegwit) {\n    if (p2wsh) {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        p2wsh.witness,\n      );\n    } else {\n      finalScriptWitness = (0, psbtutils_1.witnessStackToScriptWitness)(\n        payment.witness,\n      );\n    }\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    }\n  } else {\n    if (p2sh) {\n      finalScriptSig = p2sh.input;\n    } else {\n      finalScriptSig = payment.input;\n    }\n  }\n  return {\n    finalScriptSig,\n    finalScriptWitness,\n  };\n}\nfunction getHashAndSighashType(\n  inputs,\n  inputIndex,\n  pubkey,\n  cache,\n  sighashTypes,\n) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  const { hash, sighashType, script } = getHashForSig(\n    inputIndex,\n    input,\n    cache,\n    false,\n    sighashTypes,\n  );\n  checkScriptForPubkey(pubkey, script, 'sign');\n  return {\n    hash,\n    sighashType,\n  };\n}\nfunction getHashForSig(inputIndex, input, cache, forValidate, sighashTypes) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_ALL;\n  checkSighashTypeAllowed(sighashType, sighashTypes);\n  let hash;\n  let prevout;\n  if (input.nonWitnessUtxo) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const prevoutHash = unsignedTx.ins[inputIndex].hash;\n    const utxoHash = nonWitnessUtxoTx.getHash();\n    // If a non-witness UTXO is provided, its hash must match the hash specified in the prevout\n    if (!prevoutHash.equals(utxoHash)) {\n      throw new Error(\n        `Non-witness UTXO hash for input #${inputIndex} doesn't match the hash specified in the prevout`,\n      );\n    }\n    const prevoutIndex = unsignedTx.ins[inputIndex].index;\n    prevout = nonWitnessUtxoTx.outs[prevoutIndex];\n  } else if (input.witnessUtxo) {\n    prevout = input.witnessUtxo;\n  } else {\n    throw new Error('Need a Utxo input item for signing');\n  }\n  const { meaningfulScript, type } = getMeaningfulScript(\n    prevout.script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  if (['p2sh-p2wsh', 'p2wsh'].indexOf(type) >= 0) {\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      meaningfulScript,\n      prevout.value,\n      sighashType,\n    );\n  } else if ((0, psbtutils_1.isP2WPKH)(meaningfulScript)) {\n    // P2WPKH uses the P2PKH template for prevoutScript when signing\n    const signingScript = payments.p2pkh({\n      hash: meaningfulScript.slice(2),\n    }).output;\n    hash = unsignedTx.hashForWitnessV0(\n      inputIndex,\n      signingScript,\n      prevout.value,\n      sighashType,\n    );\n  } else {\n    // non-segwit\n    if (\n      input.nonWitnessUtxo === undefined &&\n      cache.__UNSAFE_SIGN_NONSEGWIT === false\n    )\n      throw new Error(\n        `Input #${inputIndex} has witnessUtxo but non-segwit script: ` +\n          `${meaningfulScript.toString('hex')}`,\n      );\n    if (!forValidate && cache.__UNSAFE_SIGN_NONSEGWIT !== false)\n      console.warn(\n        'Warning: Signing non-segwit inputs without the full parent transaction ' +\n          'means there is a chance that a miner could feed you incorrect information ' +\n          \"to trick you into paying large fees. This behavior is the same as Psbt's predecessor \" +\n          '(TransactionBuilder - now removed) when signing non-segwit scripts. You are not ' +\n          'able to export this Psbt with toBuffer|toBase64|toHex since it is not ' +\n          'BIP174 compliant.\\n*********************\\nPROCEED WITH CAUTION!\\n' +\n          '*********************',\n      );\n    hash = unsignedTx.hashForSignature(\n      inputIndex,\n      meaningfulScript,\n      sighashType,\n    );\n  }\n  return {\n    script: meaningfulScript,\n    sighashType,\n    hash,\n  };\n}\nfunction getAllTaprootHashesForSig(inputIndex, input, inputs, cache) {\n  const allPublicKeys = [];\n  if (input.tapInternalKey) {\n    const key = getPrevoutTaprootKey(inputIndex, input, cache);\n    if (key) {\n      allPublicKeys.push(key);\n    }\n  }\n  if (input.tapScriptSig) {\n    const tapScriptPubkeys = input.tapScriptSig.map(tss => tss.pubkey);\n    allPublicKeys.push(...tapScriptPubkeys);\n  }\n  const allHashes = allPublicKeys.map(pubicKey =>\n    getTaprootHashesForSig(inputIndex, input, inputs, pubicKey, cache),\n  );\n  return allHashes.flat();\n}\nfunction getPrevoutTaprootKey(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return (0, psbtutils_1.isP2TR)(script) ? script.subarray(2, 34) : null;\n}\nfunction trimTaprootSig(signature) {\n  return signature.length === 64 ? signature : signature.subarray(0, 64);\n}\nfunction getTaprootHashesForSig(\n  inputIndex,\n  input,\n  inputs,\n  pubkey,\n  cache,\n  tapLeafHashToSign,\n  allowedSighashTypes,\n) {\n  const unsignedTx = cache.__TX;\n  const sighashType =\n    input.sighashType || transaction_1.Transaction.SIGHASH_DEFAULT;\n  checkSighashTypeAllowed(sighashType, allowedSighashTypes);\n  const prevOuts = inputs.map((i, index) =>\n    getScriptAndAmountFromUtxo(index, i, cache),\n  );\n  const signingScripts = prevOuts.map(o => o.script);\n  const values = prevOuts.map(o => o.value);\n  const hashes = [];\n  if (input.tapInternalKey && !tapLeafHashToSign) {\n    const outputKey =\n      getPrevoutTaprootKey(inputIndex, input, cache) || Buffer.from([]);\n    if ((0, bip371_1.toXOnly)(pubkey).equals(outputKey)) {\n      const tapKeyHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n      );\n      hashes.push({ pubkey, hash: tapKeyHash });\n    }\n  }\n  const tapLeafHashes = (input.tapLeafScript || [])\n    .filter(tapLeaf => (0, psbtutils_1.pubkeyInScript)(pubkey, tapLeaf.script))\n    .map(tapLeaf => {\n      const hash = (0, bip341_1.tapleafHash)({\n        output: tapLeaf.script,\n        version: tapLeaf.leafVersion,\n      });\n      return Object.assign({ hash }, tapLeaf);\n    })\n    .filter(\n      tapLeaf => !tapLeafHashToSign || tapLeafHashToSign.equals(tapLeaf.hash),\n    )\n    .map(tapLeaf => {\n      const tapScriptHash = unsignedTx.hashForWitnessV1(\n        inputIndex,\n        signingScripts,\n        values,\n        sighashType,\n        tapLeaf.hash,\n      );\n      return {\n        pubkey,\n        hash: tapScriptHash,\n        leafHash: tapLeaf.hash,\n      };\n    });\n  return hashes.concat(tapLeafHashes);\n}\nfunction checkSighashTypeAllowed(sighashType, sighashTypes) {\n  if (sighashTypes && sighashTypes.indexOf(sighashType) < 0) {\n    const str = sighashTypeToString(sighashType);\n    throw new Error(\n      `Sighash type is not allowed. Retry the sign method passing the ` +\n        `sighashTypes array of whitelisted types. Sighash type: ${str}`,\n    );\n  }\n}\nfunction getPayment(script, scriptType, partialSig) {\n  let payment;\n  switch (scriptType) {\n    case 'multisig':\n      const sigs = getSortedSigs(script, partialSig);\n      payment = payments.p2ms({\n        output: script,\n        signatures: sigs,\n      });\n      break;\n    case 'pubkey':\n      payment = payments.p2pk({\n        output: script,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'pubkeyhash':\n      payment = payments.p2pkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n    case 'witnesspubkeyhash':\n      payment = payments.p2wpkh({\n        output: script,\n        pubkey: partialSig[0].pubkey,\n        signature: partialSig[0].signature,\n      });\n      break;\n  }\n  return payment;\n}\nfunction getScriptFromInput(inputIndex, input, cache) {\n  const unsignedTx = cache.__TX;\n  const res = {\n    script: null,\n    isSegwit: false,\n    isP2SH: false,\n    isP2WSH: false,\n  };\n  res.isP2SH = !!input.redeemScript;\n  res.isP2WSH = !!input.witnessScript;\n  if (input.witnessScript) {\n    res.script = input.witnessScript;\n  } else if (input.redeemScript) {\n    res.script = input.redeemScript;\n  } else {\n    if (input.nonWitnessUtxo) {\n      const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n        cache,\n        input,\n        inputIndex,\n      );\n      const prevoutIndex = unsignedTx.ins[inputIndex].index;\n      res.script = nonWitnessUtxoTx.outs[prevoutIndex].script;\n    } else if (input.witnessUtxo) {\n      res.script = input.witnessUtxo.script;\n    }\n  }\n  if (input.witnessScript || (0, psbtutils_1.isP2WPKH)(res.script)) {\n    res.isSegwit = true;\n  }\n  return res;\n}\nfunction getSignersFromHD(inputIndex, inputs, hdKeyPair) {\n  const input = (0, utils_1.checkForInput)(inputs, inputIndex);\n  if (!input.bip32Derivation || input.bip32Derivation.length === 0) {\n    throw new Error('Need bip32Derivation to sign with HD');\n  }\n  const myDerivations = input.bip32Derivation\n    .map(bipDv => {\n      if (bipDv.masterFingerprint.equals(hdKeyPair.fingerprint)) {\n        return bipDv;\n      } else {\n        return;\n      }\n    })\n    .filter(v => !!v);\n  if (myDerivations.length === 0) {\n    throw new Error(\n      'Need one bip32Derivation masterFingerprint to match the HDSigner fingerprint',\n    );\n  }\n  const signers = myDerivations.map(bipDv => {\n    const node = hdKeyPair.derivePath(bipDv.path);\n    if (!bipDv.pubkey.equals(node.publicKey)) {\n      throw new Error('pubkey did not match bip32Derivation');\n    }\n    return node;\n  });\n  return signers;\n}\nfunction getSortedSigs(script, partialSig) {\n  const p2ms = payments.p2ms({ output: script });\n  // for each pubkey in order of p2ms script\n  return p2ms.pubkeys\n    .map(pk => {\n      // filter partialSig array by pubkey being equal\n      return (\n        partialSig.filter(ps => {\n          return ps.pubkey.equals(pk);\n        })[0] || {}\n      ).signature;\n      // Any pubkey without a match will return undefined\n      // this last filter removes all the undefined items in the array.\n    })\n    .filter(v => !!v);\n}\nfunction scriptWitnessToWitnessStack(buffer) {\n  let offset = 0;\n  function readSlice(n) {\n    offset += n;\n    return buffer.slice(offset - n, offset);\n  }\n  function readVarInt() {\n    const vi = varuint.decode(buffer, offset);\n    offset += varuint.decode.bytes;\n    return vi;\n  }\n  function readVarSlice() {\n    return readSlice(readVarInt());\n  }\n  function readVector() {\n    const count = readVarInt();\n    const vector = [];\n    for (let i = 0; i < count; i++) vector.push(readVarSlice());\n    return vector;\n  }\n  return readVector();\n}\nfunction sighashTypeToString(sighashType) {\n  let text =\n    sighashType & transaction_1.Transaction.SIGHASH_ANYONECANPAY\n      ? 'SIGHASH_ANYONECANPAY | '\n      : '';\n  const sigMod = sighashType & 0x1f;\n  switch (sigMod) {\n    case transaction_1.Transaction.SIGHASH_ALL:\n      text += 'SIGHASH_ALL';\n      break;\n    case transaction_1.Transaction.SIGHASH_SINGLE:\n      text += 'SIGHASH_SINGLE';\n      break;\n    case transaction_1.Transaction.SIGHASH_NONE:\n      text += 'SIGHASH_NONE';\n      break;\n  }\n  return text;\n}\nfunction addNonWitnessTxCache(cache, input, inputIndex) {\n  cache.__NON_WITNESS_UTXO_BUF_CACHE[inputIndex] = input.nonWitnessUtxo;\n  const tx = transaction_1.Transaction.fromBuffer(input.nonWitnessUtxo);\n  cache.__NON_WITNESS_UTXO_TX_CACHE[inputIndex] = tx;\n  const self = cache;\n  const selfIndex = inputIndex;\n  delete input.nonWitnessUtxo;\n  Object.defineProperty(input, 'nonWitnessUtxo', {\n    enumerable: true,\n    get() {\n      const buf = self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex];\n      const txCache = self.__NON_WITNESS_UTXO_TX_CACHE[selfIndex];\n      if (buf !== undefined) {\n        return buf;\n      } else {\n        const newBuf = txCache.toBuffer();\n        self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = newBuf;\n        return newBuf;\n      }\n    },\n    set(data) {\n      self.__NON_WITNESS_UTXO_BUF_CACHE[selfIndex] = data;\n    },\n  });\n}\nfunction inputFinalizeGetAmts(inputs, tx, cache, mustFinalize) {\n  let inputAmount = 0;\n  inputs.forEach((input, idx) => {\n    if (mustFinalize && input.finalScriptSig)\n      tx.ins[idx].script = input.finalScriptSig;\n    if (mustFinalize && input.finalScriptWitness) {\n      tx.ins[idx].witness = scriptWitnessToWitnessStack(\n        input.finalScriptWitness,\n      );\n    }\n    if (input.witnessUtxo) {\n      inputAmount += input.witnessUtxo.value;\n    } else if (input.nonWitnessUtxo) {\n      const nwTx = nonWitnessUtxoTxFromCache(cache, input, idx);\n      const vout = tx.ins[idx].index;\n      const out = nwTx.outs[vout];\n      inputAmount += out.value;\n    }\n  });\n  const outputAmount = tx.outs.reduce((total, o) => total + o.value, 0);\n  const fee = inputAmount - outputAmount;\n  if (fee < 0) {\n    throw new Error('Outputs are spending more than Inputs');\n  }\n  const bytes = tx.virtualSize();\n  cache.__FEE = fee;\n  cache.__EXTRACTED_TX = tx;\n  cache.__FEE_RATE = Math.floor(fee / bytes);\n}\nfunction nonWitnessUtxoTxFromCache(cache, input, inputIndex) {\n  const c = cache.__NON_WITNESS_UTXO_TX_CACHE;\n  if (!c[inputIndex]) {\n    addNonWitnessTxCache(cache, input, inputIndex);\n  }\n  return c[inputIndex];\n}\nfunction getScriptFromUtxo(inputIndex, input, cache) {\n  const { script } = getScriptAndAmountFromUtxo(inputIndex, input, cache);\n  return script;\n}\nfunction getScriptAndAmountFromUtxo(inputIndex, input, cache) {\n  if (input.witnessUtxo !== undefined) {\n    return {\n      script: input.witnessUtxo.script,\n      value: input.witnessUtxo.value,\n    };\n  } else if (input.nonWitnessUtxo !== undefined) {\n    const nonWitnessUtxoTx = nonWitnessUtxoTxFromCache(\n      cache,\n      input,\n      inputIndex,\n    );\n    const o = nonWitnessUtxoTx.outs[cache.__TX.ins[inputIndex].index];\n    return { script: o.script, value: o.value };\n  } else {\n    throw new Error(\"Can't find pubkey in input without Utxo data\");\n  }\n}\nfunction pubkeyInInput(pubkey, input, inputIndex, cache) {\n  const script = getScriptFromUtxo(inputIndex, input, cache);\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    inputIndex,\n    'input',\n    input.redeemScript,\n    input.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction pubkeyInOutput(pubkey, output, outputIndex, cache) {\n  const script = cache.__TX.outs[outputIndex].script;\n  const { meaningfulScript } = getMeaningfulScript(\n    script,\n    outputIndex,\n    'output',\n    output.redeemScript,\n    output.witnessScript,\n  );\n  return (0, psbtutils_1.pubkeyInScript)(pubkey, meaningfulScript);\n}\nfunction redeemFromFinalScriptSig(finalScript) {\n  if (!finalScript) return;\n  const decomp = bscript.decompile(finalScript);\n  if (!decomp) return;\n  const lastItem = decomp[decomp.length - 1];\n  if (\n    !Buffer.isBuffer(lastItem) ||\n    isPubkeyLike(lastItem) ||\n    isSigLike(lastItem)\n  )\n    return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction redeemFromFinalWitnessScript(finalScript) {\n  if (!finalScript) return;\n  const decomp = scriptWitnessToWitnessStack(finalScript);\n  const lastItem = decomp[decomp.length - 1];\n  if (isPubkeyLike(lastItem)) return;\n  const sDecomp = bscript.decompile(lastItem);\n  if (!sDecomp) return;\n  return lastItem;\n}\nfunction compressPubkey(pubkey) {\n  if (pubkey.length === 65) {\n    const parity = pubkey[64] & 1;\n    const newKey = pubkey.slice(0, 33);\n    newKey[0] = 2 | parity;\n    return newKey;\n  }\n  return pubkey.slice();\n}\nfunction isPubkeyLike(buf) {\n  return buf.length === 33 && bscript.isCanonicalPubKey(buf);\n}\nfunction isSigLike(buf) {\n  return bscript.isCanonicalScriptSignature(buf);\n}\nfunction getMeaningfulScript(\n  script,\n  index,\n  ioType,\n  redeemScript,\n  witnessScript,\n) {\n  const isP2SH = (0, psbtutils_1.isP2SHScript)(script);\n  const isP2SHP2WSH =\n    isP2SH && redeemScript && (0, psbtutils_1.isP2WSHScript)(redeemScript);\n  const isP2WSH = (0, psbtutils_1.isP2WSHScript)(script);\n  if (isP2SH && redeemScript === undefined)\n    throw new Error('scriptPubkey is P2SH but redeemScript missing');\n  if ((isP2WSH || isP2SHP2WSH) && witnessScript === undefined)\n    throw new Error(\n      'scriptPubkey or redeemScript is P2WSH but witnessScript missing',\n    );\n  let meaningfulScript;\n  if (isP2SHP2WSH) {\n    meaningfulScript = witnessScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n    checkWitnessScript(index, redeemScript, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2WSH) {\n    meaningfulScript = witnessScript;\n    checkWitnessScript(index, script, witnessScript, ioType);\n    checkInvalidP2WSH(meaningfulScript);\n  } else if (isP2SH) {\n    meaningfulScript = redeemScript;\n    checkRedeemScript(index, script, redeemScript, ioType);\n  } else {\n    meaningfulScript = script;\n  }\n  return {\n    meaningfulScript,\n    type: isP2SHP2WSH\n      ? 'p2sh-p2wsh'\n      : isP2SH\n      ? 'p2sh'\n      : isP2WSH\n      ? 'p2wsh'\n      : 'raw',\n  };\n}\nfunction checkInvalidP2WSH(script) {\n  if (\n    (0, psbtutils_1.isP2WPKH)(script) ||\n    (0, psbtutils_1.isP2SHScript)(script)\n  ) {\n    throw new Error('P2WPKH or P2SH can not be contained within P2WSH');\n  }\n}\nfunction classifyScript(script) {\n  if ((0, psbtutils_1.isP2WPKH)(script)) return 'witnesspubkeyhash';\n  if ((0, psbtutils_1.isP2PKH)(script)) return 'pubkeyhash';\n  if ((0, psbtutils_1.isP2MS)(script)) return 'multisig';\n  if ((0, psbtutils_1.isP2PK)(script)) return 'pubkey';\n  return 'nonstandard';\n}\nfunction range(n) {\n  return [...Array(n).keys()];\n}\n", "'use strict';\nObject.defineProperty(exports, '__esModule', { value: true });\nexports.initEccLib =\n  exports.Transaction =\n  exports.opcodes =\n  exports.Psbt =\n  exports.Block =\n  exports.script =\n  exports.payments =\n  exports.networks =\n  exports.crypto =\n  exports.address =\n    void 0;\nconst address = require('./address');\nexports.address = address;\nconst crypto = require('./crypto');\nexports.crypto = crypto;\nconst networks = require('./networks');\nexports.networks = networks;\nconst payments = require('./payments');\nexports.payments = payments;\nconst script = require('./script');\nexports.script = script;\nvar block_1 = require('./block');\nObject.defineProperty(exports, 'Block', {\n  enumerable: true,\n  get: function () {\n    return block_1.Block;\n  },\n});\nvar psbt_1 = require('./psbt');\nObject.defineProperty(exports, 'Psbt', {\n  enumerable: true,\n  get: function () {\n    return psbt_1.Psbt;\n  },\n});\n/** @hidden */\nvar ops_1 = require('./ops');\nObject.defineProperty(exports, 'opcodes', {\n  enumerable: true,\n  get: function () {\n    return ops_1.OPS;\n  },\n});\nvar transaction_1 = require('./transaction');\nObject.defineProperty(exports, 'Transaction', {\n  enumerable: true,\n  get: function () {\n    return transaction_1.Transaction;\n  },\n});\nvar ecc_lib_1 = require('./ecc_lib');\nObject.defineProperty(exports, 'initEccLib', {\n  enumerable: true,\n  get: function () {\n    return ecc_lib_1.initEccLib;\n  },\n});\n"],
  "mappings": "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",
  "names": ["import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "i", "j", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "require_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "Buffer", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "GlobalTypes", "InputTypes", "OutputTypes", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "import_dist", "require_psbt", "import_dist", "require_src", "import_dist"]
}
